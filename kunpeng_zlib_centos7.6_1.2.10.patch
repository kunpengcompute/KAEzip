diff -Naru zlib-1.2.7/compress.c zlib-1.2.7_new/compress.c
--- zlib-1.2.7/compress.c	2005-12-12 02:27:31.000000000 +0800
+++ zlib-1.2.7_new/compress.c	2020-06-12 14:47:58.888589000 +0800
@@ -7,7 +7,8 @@
 
 #define ZLIB_INTERNAL
 #include "zlib.h"
-
+#include "zip_zlib.h"
+#include "zip_common.h"
 /* ===========================================================================
      Compresses the source buffer into the destination buffer. The level
    parameter has the same meaning as in deflateInit.  sourceLen is the byte
@@ -75,6 +76,10 @@
 uLong ZEXPORT compressBound (sourceLen)
     uLong sourceLen;
 {
+#ifdef ZIP_ACC
+    return sourceLen + (sourceLen >> 3) + 13;
+#else
     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
            (sourceLen >> 25) + 13;
+#endif
 }
diff -Naru zlib-1.2.7/configure zlib-1.2.7_new/configure
--- zlib-1.2.7/configure	2012-05-02 12:17:08.000000000 +0800
+++ zlib-1.2.7_new/configure	2020-06-12 14:47:58.891089400 +0800
@@ -18,6 +18,18 @@
 echo $0 $* >> configure.log
 date >> configure.log
 
+# get source directory
+SRCDIR=`dirname $0`
+if test $SRCDIR = "."; then
+    ZINC=""
+    ZINCOUT="-I."
+    SRCDIR=""
+else
+    ZINC="-include zconf.h"
+    ZINCOUT="-I. -I$(SRCDIR)"
+    SRCDIR="$SRCDIR/"
+fi
+
 # set command prefix for cross-compilation
 if [ -n "${CHOST}" ]; then
     uname="`echo "${CHOST}" | sed -e 's/^[^-]*-\([^-]*\)$/\1/' -e 's/^[^-]*-[^-]*-\([^-]*\)$/\1/' -e 's/^[^-]*-[^-]*-\([^-]*\)-.*$/\1/'`"
@@ -28,10 +40,10 @@
 STATICLIB=libz.a
 
 # extract zlib version numbers from zlib.h
-VER=`sed -n -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`
-VER3=`sed -n -e '/VERSION "/s/.*"\([0-9]*\\.[0-9]*\\.[0-9]*\).*/\1/p' < zlib.h`
-VER2=`sed -n -e '/VERSION "/s/.*"\([0-9]*\\.[0-9]*\)\\..*/\1/p' < zlib.h`
-VER1=`sed -n -e '/VERSION "/s/.*"\([0-9]*\)\\..*/\1/p' < zlib.h`
+VER=`sed -n -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < ${SRCDIR}zlib.h`
+VER3=`sed -n -e '/VERSION "/s/.*"\([0-9]*\\.[0-9]*\\.[0-9]*\).*/\1/p' < ${SRCDIR}zlib.h`
+VER2=`sed -n -e '/VERSION "/s/.*"\([0-9]*\\.[0-9]*\)\\..*/\1/p' < ${SRCDIR}zlib.h`
+VER1=`sed -n -e '/VERSION "/s/.*"\([0-9]*\)\\..*/\1/p' < ${SRCDIR}zlib.h`
 
 # establish commands for library building
 if "${CROSS_PREFIX}ar" --version >/dev/null 2>/dev/null || test $? -lt 126; then
@@ -78,6 +90,7 @@
 PIC_OBJC='$(PIC_OBJZ) $(PIC_OBJG)'
 
 # process command line options
+libwd_path="/usr/local/lib"
 while test $# -ge 1
 do
 case "$1" in
@@ -88,6 +101,7 @@
       echo '    [--includedir=INCLUDEDIR] [--archs="-arch i386 -arch x86_64"]' | tee -a configure.log
         exit 0 ;;
     -p*=* | --prefix=*) prefix=`echo $1 | sed 's/.*=//'`; shift ;;
+    -Wl,-rpath,*) libwd_path=`echo $1 | sed 's/.*,//'`; shift ;;
     -e*=* | --eprefix=*) exec_prefix=`echo $1 | sed 's/.*=//'`; shift ;;
     -l*=* | --libdir=*) libdir=`echo $1 | sed 's/.*=//'`; shift ;;
     --sharedlibdir=*) sharedlibdir=`echo $1 | sed 's/.*=//'`; shift ;;
@@ -110,6 +124,25 @@
     esac
 done
 
+# add accelerate parameters
+WD_PATH="../../../drivers/warpdrive"
+WD_SOURCE_PATH="${libwd_path%/*}/include/warpdrive"
+WD_RPM_PATH="/usr/include/warpdrive"
+LDFLAGS=""
+if [ -d "${WD_PATH}" ]; then	
+	LDFLAGS+=" -L${WD_PATH}/.libs"
+fi
+if [ -d "${libwd_path}" ]; then	
+	LDFLAGS+=" -L${libwd_path}"
+fi
+if [ -d "/usr/lib64" ]; then	
+	LDFLAGS+=" -L/usr/lib64"
+fi
+LDFLAGS+=" -lwd -Wl,-rpath,${libwd_path}"
+
+ZINC+=" -I${WD_PATH} -I${WD_SOURCE_PATH} -I${WD_RPM_PATH} "
+ZINCOUT+=" -I${WD_PATH} -I${WD_SOURCE_PATH} -I${WD_RPM_PATH}"
+
 # define functions for testing compiler and library characteristics and logging the results
 test=ztest$$
 
@@ -127,7 +160,7 @@
 cat > $test.c <<EOF
 #error error
 EOF
-if ($CC -c $CFLAGS $test.c) 2>/dev/null; then
+if ($CC -c $CFLAGS ${LDFLAGS} $test.c) 2>/dev/null; then
   try()
   {
     show $*
@@ -198,9 +231,9 @@
   fi
   case "$uname" in
   Linux* | linux* | GNU | GNU/* | solaris*)
-        LDSHARED=${LDSHARED-"$cc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map"} ;;
+        LDSHARED=${LDSHARED-"$cc -shared -Wl,-soname,libz.so.1,--version-script,${SRCDIR}zlib.map"} ;;
   *BSD | *bsd* | DragonFly)
-        LDSHARED=${LDSHARED-"$cc -shared -Wl,-soname,libz.so.1,--version-script,zlib.map"}
+        LDSHARED=${LDSHARED-"$cc -shared -Wl,-soname,libz.so.1,--version-script,${SRCDIR}zlib.map"}
         LDCONFIG="ldconfig -m" ;;
   CYGWIN* | Cygwin* | cygwin* | OS/2*)
         EXE='.exe' ;;
@@ -297,6 +330,9 @@
                  esac
              fi
          fi
+         if test -n "$ZINC"; then
+             ZINC='-I- -I. -I$(SRCDIR)'
+         fi
          ;;
   SunOS\ 4*) SFLAGS=${CFLAGS-"-O2 -PIC"}
              CFLAGS=${CFLAGS-"-O2"}
@@ -338,7 +374,7 @@
 if test $shared -eq 1; then
   echo Checking for shared library support... | tee -a configure.log
   # we must test in two steps (cc then ld), required at least on SunOS 4.x
-  if try $CC -w -c $SFLAGS $test.c &&
+  if try $CC -w -c $SFLAGS $test.c ${LDFLAGS} &&
      try $LDSHARED $SFLAGS -o $test$shared_ext $test.o; then
     echo Building shared library $SHAREDLIBV with $CC. | tee -a configure.log
   elif test -z "$old_cc" -a -z "$old_cflags"; then
@@ -428,7 +464,7 @@
 fi
 
 # copy clean zconf.h for subsequent edits
-cp -p zconf.h.in zconf.h
+cp -p ${SRCDIR}zconf.h.in zconf.h
 
 echo >> configure.log
 
@@ -763,7 +799,7 @@
 echo >> configure.log
 
 # udpate Makefile with the configure results
-sed < Makefile.in "
+sed < ${SRCDIR}Makefile.in "
 /^CC *=/s#=.*#=$CC#
 /^CFLAGS *=/s#=.*#=$CFLAGS#
 /^SFLAGS *=/s#=.*#=$SFLAGS#
@@ -780,6 +816,8 @@
 /^LDCONFIG *=/s#=.*#=$LDCONFIG#
 /^LDSHAREDLIBC *=/s#=.*#=$LDSHAREDLIBC#
 /^EXE *=/s#=.*#=$EXE#
+/^ZINC *=/s#=.*#=$ZINC#
+/^ZINCOUT *=/s#=.*#=$ZINCOUT#
 /^prefix *=/s#=.*#=$prefix#
 /^exec_prefix *=/s#=.*#=$exec_prefix#
 /^libdir *=/s#=.*#=$libdir#
@@ -793,7 +831,7 @@
 " > Makefile
 
 # create zlib.pc with the configure results
-sed < zlib.pc.in "
+sed < ${SRCDIR}zlib.pc.in "
 /^CC *=/s#=.*#=$CC#
 /^CFLAGS *=/s#=.*#=$CFLAGS#
 /^CPP *=/s#=.*#=$CPP#
diff -Naru zlib-1.2.7/deflate.c zlib-1.2.7_new/deflate.c
--- zlib-1.2.7/deflate.c	2020-06-12 14:55:46.882016700 +0800
+++ zlib-1.2.7_new/deflate.c	2020-06-12 14:47:58.893089600 +0800
@@ -4,6 +4,11 @@
  */
 
 /*
+ * 2019.09.30 Add an adaptation hardware acceleration algorithm branch.
+ *            Copyright (C) 2019. Huawei Technologies Co.,Ltd.
+ */
+
+/*
  *  ALGORITHM
  *
  *      The "deflation" process depends on being able to identify portions
@@ -50,6 +55,9 @@
 /* @(#) $Id$ */
 
 #include "deflate.h"
+#include "zip_zlib.h"
+#include "zip_common.h"
+extern int zipdev_flag;
 
 const char deflate_copyright[] =
    " deflate 1.2.7 Copyright 1995-2012 Jean-loup Gailly and Mark Adler ";
@@ -210,7 +218,7 @@
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+int ZEXPORT sw_deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
                   version, stream_size)
     z_streamp strm;
     int  level;
@@ -319,6 +327,33 @@
     return deflateReset(strm);
 }
 
+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+#ifdef ZIP_ACC
+    zipdev_flag = zip_get_devices();
+    if (zipdev_flag) {
+        return zip_deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                    version, stream_size);
+    } else {
+        return sw_deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                    version, stream_size);
+    }
+#else
+    return sw_deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                version, stream_size);
+#endif
+
+}
+
 /* ========================================================================= */
 int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
     z_streamp strm;
@@ -565,6 +600,17 @@
     z_streamp strm;
     uLong sourceLen;
 {
+#ifdef ZIP_ACC
+    return sourceLen + (sourceLen >> 3) + 13;
+#else
+    return sw_deflateBound(strm, sourceLen);
+#endif
+}
+
+uLong ZEXPORT sw_deflateBound(strm, sourceLen)
+    z_streamp strm;
+    uLong sourceLen;
+{
     deflate_state *s;
     uLong complen, wraplen;
     Bytef *str;
@@ -660,7 +706,7 @@
 }
 
 /* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
+int ZEXPORT sw_deflate (strm, flush)
     z_streamp strm;
     int flush;
 {
@@ -980,8 +1026,28 @@
     return s->pending != 0 ? Z_OK : Z_STREAM_END;
 }
 
+int ZEXPORT deflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) {
+        if (strm->reserved != 0 && flush != Z_PARTIAL_FLUSH 
+            && flush != Z_TREES) {
+            return zip_deflate(strm, flush);
+        } else {
+            return sw_deflate(strm, flush);
+        }
+    } else {
+        return sw_deflate(strm, flush);
+    }
+#else
+    return sw_deflate(strm, flush);
+#endif
+}
+
 /* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
+int ZEXPORT sw_deflateEnd (strm)
     z_streamp strm;
 {
     int status;
@@ -1011,6 +1077,19 @@
     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
 }
 
+int ZEXPORT deflateEnd (strm)
+    z_streamp strm;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) {
+        return zip_deflateEnd(strm);
+    } else {
+        return sw_deflateEnd(strm);
+    }
+#endif
+    return sw_deflateEnd(strm);
+}
+
 /* =========================================================================
  * Copy the source state to the destination state.
  * To simplify the source, this is not supported for 16-bit MSDOS (which
diff -Naru zlib-1.2.7/inflate.c zlib-1.2.7_new/inflate.c
--- zlib-1.2.7/inflate.c	2012-02-13 06:20:33.000000000 +0800
+++ zlib-1.2.7_new/inflate.c	2020-06-12 14:47:58.895089900 +0800
@@ -4,6 +4,11 @@
  */
 
 /*
+ * 2019.09.30 Add an adaptation hardware acceleration algorithm branch.
+ *            Copyright (C) 2019. Huawei Technologies Co.,Ltd.
+ */
+
+/*
  * Change history:
  *
  * 1.2.beta0    24 Nov 2002
@@ -84,7 +89,9 @@
 #include "inftrees.h"
 #include "inflate.h"
 #include "inffast.h"
-
+#include "zip_zlib.h"
+#include "zip_common.h"
+extern int zipdev_flag;
 #ifdef MAKEFIXED
 #  ifndef BUILDFIXED
 #    define BUILDFIXED
@@ -125,7 +132,7 @@
     return Z_OK;
 }
 
-int ZEXPORT inflateReset(strm)
+int ZEXPORT sw_inflateReset(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
@@ -138,6 +145,20 @@
     return inflateResetKeep(strm);
 }
 
+int ZEXPORT inflateReset(strm)
+z_streamp strm;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) {
+        return zip_inflateReset(strm);       
+    } else {
+        return sw_inflateReset(strm);       
+    }
+#else
+    return sw_inflateReset(strm);
+#endif
+}
+
 int ZEXPORT inflateReset2(strm, windowBits)
 z_streamp strm;
 int windowBits;
@@ -173,10 +194,10 @@
     /* update state and reset the rest of it */
     state->wrap = wrap;
     state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
+    return sw_inflateReset(strm);
 }
 
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+int ZEXPORT sw_inflateInit2_(strm, windowBits, version, stream_size)
 z_streamp strm;
 int windowBits;
 const char *version;
@@ -218,6 +239,24 @@
     return ret;
 }
 
+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
+{ 
+#ifdef ZIP_ACC
+    zipdev_flag = zip_get_devices();
+    if (zipdev_flag != 0) {
+        return zip_inflateInit2_(strm, windowBits, version, stream_size);
+    } else {
+        return sw_inflateInit2_(strm, windowBits, version, stream_size);
+    }
+#else
+    return sw_inflateInit2_(strm, windowBits, version, stream_size);
+#endif
+}
+
 int ZEXPORT inflateInit_(strm, version, stream_size)
 z_streamp strm;
 const char *version;
@@ -601,7 +640,7 @@
    will return Z_BUF_ERROR if it has not reached the end of the stream.
  */
 
-int ZEXPORT inflate(strm, flush)
+int ZEXPORT sw_inflate(strm, flush)
 z_streamp strm;
 int flush;
 {
@@ -1250,7 +1289,27 @@
     return ret;
 }
 
-int ZEXPORT inflateEnd(strm)
+int ZEXPORT inflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) {
+        if (strm->reserved != 0 && flush != Z_PARTIAL_FLUSH 
+            && flush != Z_TREES){
+            return zip_inflate(strm, flush);
+        } else {
+            return sw_inflate(strm, flush);
+        }
+    } else {
+        return sw_inflate(strm, flush);
+    }
+#else
+    return sw_inflate(strm, flush);
+#endif
+}
+
+int ZEXPORT sw_inflateEnd(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
@@ -1264,6 +1323,20 @@
     return Z_OK;
 }
 
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) { 
+        return zip_inflateEnd(strm);
+    } else {
+        return sw_inflateEnd(strm);
+    }
+    
+#endif
+    return sw_inflateEnd(strm);
+}
+
 int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
 z_streamp strm;
 const Bytef *dictionary;
@@ -1358,7 +1431,7 @@
     return next;
 }
 
-int ZEXPORT inflateSync(strm)
+int ZEXPORT sw_inflateSync(strm)
 z_streamp strm;
 {
     unsigned len;               /* number of bytes to look at or looked at */
@@ -1395,12 +1468,25 @@
     /* return no joy or set up to restart inflate() on a new block */
     if (state->have != 4) return Z_DATA_ERROR;
     in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
+    sw_inflateReset(strm);
     strm->total_in = in;  strm->total_out = out;
     state->mode = TYPE;
     return Z_OK;
 }
 
+int ZEXPORT inflateSync(strm)
+z_streamp strm;
+{
+#ifdef ZIP_ACC
+    if (zipdev_flag) {
+        return sw_inflateSync(strm);
+    } else {
+        return sw_inflateSync(strm);
+    }
+#endif
+    return sw_inflateSync(strm);
+}
+
 /*
    Returns true if inflate is currently at the end of a block generated by
    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
diff -Naru zlib-1.2.7/LICENSE zlib-1.2.7_new/LICENSE
--- zlib-1.2.7/LICENSE	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/LICENSE	2020-06-12 14:47:58.896090000 +0800
@@ -0,0 +1,26 @@
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.11, January 15th, 2017
+
+  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+*/
\ No newline at end of file
diff -Naru zlib-1.2.7/Makefile.in zlib-1.2.7_new/Makefile.in
--- zlib-1.2.7/Makefile.in	2012-04-23 13:58:06.000000000 +0800
+++ zlib-1.2.7_new/Makefile.in	2020-06-12 14:47:58.898590300 +0800
@@ -23,10 +23,13 @@
 #CFLAGS=-g -DDEBUG
 #CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
 #           -Wstrict-prototypes -Wmissing-prototypes
-
+wd_path=../../../drivers/warpdrive
+wd_source_path=/usr/local/lib
+wd_rpm_path=/usr/lib64
 SFLAGS=-O
 LDFLAGS=
 TEST_LDFLAGS=-L. libz.a
+TEST_LDFLAGS+=${LDFLAGS}
 LDSHARED=$(CC)
 CPP=$(CC) -E
 
@@ -53,12 +56,15 @@
 mandir = ${prefix}/share/man
 man3dir = ${mandir}/man3
 pkgconfigdir = ${libdir}/pkgconfig
+SRCDIR=
+ZINC=
+ZINCOUT=-I.
 
-OBJZ = adler32.o crc32.o deflate.o infback.o inffast.o inflate.o inftrees.o trees.o zutil.o
+OBJZ = adler32.o crc32.o zip_deflate.o zip_common.o zip_queue_scheduler.o deflate.o infback.o inffast.o zip_inflate.o inflate.o inftrees.o trees.o zutil.o zlib_acc_conf.o zlib_acc_log.o
 OBJG = compress.o uncompr.o gzclose.o gzlib.o gzread.o gzwrite.o
 OBJC = $(OBJZ) $(OBJG)
 
-PIC_OBJZ = adler32.lo crc32.lo deflate.lo infback.lo inffast.lo inflate.lo inftrees.lo trees.lo zutil.lo
+PIC_OBJZ = adler32.lo crc32.lo zip_deflate.lo zip_common.lo zip_queue_scheduler.lo deflate.lo infback.lo inffast.lo zip_inflate.lo inflate.lo inftrees.lo trees.lo zutil.lo zlib_acc_conf.lo zlib_acc_log.lo
 PIC_OBJG = compress.lo uncompr.lo gzclose.lo gzlib.lo gzread.lo gzwrite.lo
 PIC_OBJC = $(PIC_OBJZ) $(PIC_OBJG)
 
@@ -140,24 +146,185 @@
 	mv _match.o match.lo
 	rm -f _match.s
 
-example.o: test/example.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/example.c
+example.o: $(SRCDIR)test/example.c $(SRCDIR)zlib.h zconf.h
+	$(CC) $(CFLAGS) $(ZINCOUT) -c -o $@ $(SRCDIR)test/example.c
+
+minigzip.o: $(SRCDIR)test/minigzip.c $(SRCDIR)zlib.h zconf.h
+	$(CC) $(CFLAGS) $(ZINCOUT) -c -o $@ $(SRCDIR)test/minigzip.c
+
+example64.o: $(SRCDIR)test/example.c $(SRCDIR)zlib.h zconf.h
+	$(CC) $(CFLAGS) $(ZINCOUT) -D_FILE_OFFSET_BITS=64 -c -o $@ $(SRCDIR)test/example.c
+
+minigzip64.o: $(SRCDIR)test/minigzip.c $(SRCDIR)zlib.h zconf.h
+	$(CC) $(CFLAGS) $(ZINCOUT) -D_FILE_OFFSET_BITS=64 -c -o $@ $(SRCDIR)test/minigzip.c
+
+adler32.o: $(SRCDIR)adler32.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)adler32.c
+
+crc32.o: $(SRCDIR)crc32.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)crc32.c
+
+deflate.o: $(SRCDIR)deflate.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)deflate.c
+
+zip_deflate.o: $(SRCDIR)zip_deflate.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zip_deflate.c
+
+zip_common.o: $(SRCDIR)zip_common.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zip_common.c
+
+zip_queue_scheduler.o: $(SRCDIR)zip_queue_scheduler.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zip_queue_scheduler.c
+
+infback.o: $(SRCDIR)infback.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)infback.c
+
+inffast.o: $(SRCDIR)inffast.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inffast.c
+
+inflate.o: $(SRCDIR)inflate.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inflate.c
+
+zip_inflate.o: $(SRCDIR)zip_inflate.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zip_inflate.c
+
+inftrees.o: $(SRCDIR)inftrees.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inftrees.c
+
+trees.o: $(SRCDIR)trees.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)trees.c
 
-minigzip.o: test/minigzip.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/minigzip.c
+zutil.o: $(SRCDIR)zutil.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zutil.c
 
-example64.o: test/example.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -D_FILE_OFFSET_BITS=64 -c -o $@ test/example.c
+zlib_acc_conf.o: $(SRCDIR)zlib_acc_conf.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zlib_acc_conf.c
 
-minigzip64.o: test/minigzip.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -D_FILE_OFFSET_BITS=64 -c -o $@ test/minigzip.c
+zlib_acc_log.o: $(SRCDIR)zlib_acc_log.c
+	$(CC) $(SFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zlib_acc_log.c
 
-.SUFFIXES: .lo
+compress.o: $(SRCDIR)compress.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)compress.c
+
+uncompr.o: $(SRCDIR)uncompr.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)uncompr.c
+
+gzclose.o: $(SRCDIR)gzclose.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzclose.c
+
+gzlib.o: $(SRCDIR)gzlib.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzlib.c
+
+gzread.o: $(SRCDIR)gzread.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzread.c
+
+gzwrite.o: $(SRCDIR)gzwrite.c
+	$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzwrite.c
+
+adler32.lo: $(SRCDIR)adler32.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/adler32.o $(SRCDIR)adler32.c
+	-@mv objs/adler32.o $@
+
+crc32.lo: $(SRCDIR)crc32.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/crc32.o $(SRCDIR)crc32.c
+	-@mv objs/crc32.o $@
+
+deflate.lo: $(SRCDIR)deflate.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/deflate.o $(SRCDIR)deflate.c
+	-@mv objs/deflate.o $@
+
+zip_deflate.lo: $(SRCDIR)zip_deflate.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zip_deflate.o $(SRCDIR)zip_deflate.c
+	-@mv objs/zip_deflate.o $@
+
+zip_inflate.lo: $(SRCDIR)zip_inflate.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zip_inflate.o $(SRCDIR)zip_inflate.c
+	-@mv objs/zip_inflate.o $@
+
+zip_common.lo: $(SRCDIR)zip_common.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zip_common.o $(SRCDIR)zip_common.c
+	-@mv objs/zip_common.o $@
+
+zip_queue_scheduler.lo: $(SRCDIR)zip_queue_scheduler.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zip_queue_scheduler.o $(SRCDIR)zip_queue_scheduler.c
+	-@mv objs/zip_queue_scheduler.o $@
+
+infback.lo: $(SRCDIR)infback.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/infback.o $(SRCDIR)infback.c
+	-@mv objs/infback.o $@
+
+inffast.lo: $(SRCDIR)inffast.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inffast.o $(SRCDIR)inffast.c
+	-@mv objs/inffast.o $@
+
+inflate.lo: $(SRCDIR)inflate.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inflate.o $(SRCDIR)inflate.c
+	-@mv objs/inflate.o $@
+
+inftrees.lo: $(SRCDIR)inftrees.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inftrees.o $(SRCDIR)inftrees.c
+	-@mv objs/inftrees.o $@
+
+trees.lo: $(SRCDIR)trees.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/trees.o $(SRCDIR)trees.c
+	-@mv objs/trees.o $@
+
+zutil.lo: $(SRCDIR)zutil.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zutil.o $(SRCDIR)zutil.c
+	-@mv objs/zutil.o $@
+
+zlib_acc_conf.lo: $(SRCDIR)zlib_acc_conf.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zlib_acc_conf.o $(SRCDIR)zlib_acc_conf.c
+	-@mv objs/zlib_acc_conf.o $@
+
+zlib_acc_log.lo: $(SRCDIR)zlib_acc_log.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zlib_acc_log.o $(SRCDIR)zlib_acc_log.c
+	-@mv objs/zlib_acc_log.o $@
+
+compress.lo: $(SRCDIR)compress.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/compress.o $(SRCDIR)compress.c
+	-@mv objs/compress.o $@
+
+uncompr.lo: $(SRCDIR)uncompr.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/uncompr.o $(SRCDIR)uncompr.c
+	-@mv objs/uncompr.o $@
+
+gzclose.lo: $(SRCDIR)gzclose.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzclose.o $(SRCDIR)gzclose.c
+	-@mv objs/gzclose.o $@
+
+gzlib.lo: $(SRCDIR)gzlib.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzlib.o $(SRCDIR)gzlib.c
+	-@mv objs/gzlib.o $@
+
+gzread.lo: $(SRCDIR)gzread.c
+	-@mkdir objs 2>/dev/null || test -d objs
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzread.o $(SRCDIR)gzread.c
+	-@mv objs/gzread.o $@
 
-.c.lo:
+gzwrite.lo: $(SRCDIR)gzwrite.c
 	-@mkdir objs 2>/dev/null || test -d objs
-	$(CC) $(SFLAGS) -DPIC -c -o objs/$*.o $<
-	-@mv objs/$*.o $@
+	$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzwrite.o $(SRCDIR)gzwrite.c
+	-@mv objs/gzwrite.o $@
 
 placebo $(SHAREDLIBV): $(PIC_OBJS) libz.a
 	$(LDSHARED) $(SFLAGS) -o $@ $(PIC_OBJS) $(LDSHAREDLIBC) $(LDFLAGS)
@@ -173,10 +340,10 @@
 	$(CC) $(CFLAGS) -o $@ minigzip.o $(TEST_LDFLAGS)
 
 examplesh$(EXE): example.o $(SHAREDLIBV)
-	$(CC) $(CFLAGS) -o $@ example.o -L. $(SHAREDLIBV)
+	$(CC) $(CFLAGS) -o $@ example.o -L. $(TEST_LDFLAGS)  $(SHAREDLIBV)
 
 minigzipsh$(EXE): minigzip.o $(SHAREDLIBV)
-	$(CC) $(CFLAGS) -o $@ minigzip.o -L. $(SHAREDLIBV)
+	$(CC) $(CFLAGS) -o $@ minigzip.o -L. $(TEST_LDFLAGS)  $(SHAREDLIBV)
 
 example64$(EXE): example64.o $(STATICLIB)
 	$(CC) $(CFLAGS) -o $@ example64.o $(TEST_LDFLAGS)
@@ -203,7 +370,7 @@
 	  ln -s $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBM); \
 	  ($(LDCONFIG) || true)  >/dev/null 2>&1; \
 	fi
-	cp zlib.3 $(DESTDIR)$(man3dir)
+	cp $(SRCDIR)zlib.3 $(DESTDIR)$(man3dir)
 	chmod 644 $(DESTDIR)$(man3dir)/zlib.3
 	cp zlib.pc $(DESTDIR)$(pkgconfigdir)
 	chmod 644 $(DESTDIR)$(pkgconfigdir)/zlib.pc
@@ -212,7 +379,7 @@
 
 install: install-libs
 	-@if [ ! -d $(DESTDIR)$(includedir)   ]; then mkdir -p $(DESTDIR)$(includedir); fi
-	cp zlib.h zconf.h $(DESTDIR)$(includedir)
+	cp $(SRCDIR)zlib.h zconf.h $(DESTDIR)$(includedir)
 	chmod 644 $(DESTDIR)$(includedir)/zlib.h $(DESTDIR)$(includedir)/zconf.h
 
 uninstall:
@@ -226,18 +393,18 @@
 
 docs: zlib.3.pdf
 
-zlib.3.pdf: zlib.3
-	groff -mandoc -f H -T ps zlib.3 | ps2pdf - zlib.3.pdf
+zlib.3.pdf: $(SRCDIR)zlib.3
+	groff -mandoc -f H -T ps $(SRCDIR)zlib.3 | ps2pdf - zlib.3.pdf
 
-zconf.h.cmakein: zconf.h.in
+zconf.h.cmakein: $(SRCDIR)zconf.h.in
 	-@ TEMPFILE=`mktemp __XXXXXX`; \
 	echo "/#define ZCONF_H/ a\\\\\n#cmakedefine Z_PREFIX\\\\\n#cmakedefine Z_HAVE_UNISTD_H\n" >> $$TEMPFILE &&\
-	sed -f $$TEMPFILE zconf.h.in > zconf.h.cmakein &&\
-	touch -r zconf.h.in zconf.h.cmakein &&\
+	sed -f $$TEMPFILE $(SRCDIR)zconf.h.in > zconf.h.cmakein &&\
+	touch -r zconf.h.in $(SRCDIR)zconf.h.cmakein &&\
 	rm $$TEMPFILE
 
-zconf: zconf.h.in
-	cp -p zconf.h.in zconf.h
+zconf: $(SRCDIR)zconf.h.in
+	cp -p $(SRCDIR)zconf.h.in zconf.h
 
 mostlyclean: clean
 clean:
@@ -255,12 +422,15 @@
 distclean: clean zconf zconf.h.cmakein docs
 	rm -f Makefile zlib.pc configure.log
 	-@rm -f .DS_Store
-	-@printf 'all:\n\t-@echo "Please use ./configure first.  Thank you."\n' > Makefile
-	-@printf '\ndistclean:\n\tmake -f Makefile.in distclean\n' >> Makefile
-	-@touch -r Makefile.in Makefile
+	@if [ -f Makefile.in ]; then \
+	printf 'all:\n\t-@echo "Please use ./configure first.  Thank you."\n' > Makefile ; \
+	printf '\ndistclean:\n\tmake -f Makefile.in distclean\n' >> Makefile ; \
+	touch -r $(SRCDIR)Makefile.in Makefile ; fi
+	@if [ ! -f zconf.h.in ]; then rm -f zconf.h zconf.h.cmakein ; fi
+	@if [ ! -f zlib.3 ]; then rm -f zlib.3.pdf ; fi
 
 tags:
-	etags *.[ch]
+	etags $(SRCDIR)*.[ch]
 
 depend:
 	makedepend -- $(CFLAGS) -- *.[ch]
@@ -276,13 +446,18 @@
 inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
 inftrees.o: zutil.h zlib.h zconf.h inftrees.h
 trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
+zlib_acc_log.o: zlib_acc_log.h zlib_acc_conf.h
+zlib_acc_conf.o: zlib_acc_conf.h
 
 adler32.lo zutil.lo: zutil.h zlib.h zconf.h
 gzclose.lo gzlib.lo gzread.lo gzwrite.lo: zlib.h zconf.h gzguts.h
 compress.lo example.lo minigzip.lo uncompr.lo: zlib.h zconf.h
 crc32.lo: zutil.h zlib.h zconf.h crc32.h
 deflate.lo: deflate.h zutil.h zlib.h zconf.h
+zip_deflate.lo inflate.lo zip_common.lo zip_queue_scheduler.lo:zip_zlib.h zip_common.h zip_queue_scheduler.h
 infback.lo inflate.lo: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h inffixed.h
 inffast.lo: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
 inftrees.lo: zutil.h zlib.h zconf.h inftrees.h
 trees.lo: deflate.h zutil.h zlib.h zconf.h trees.h
+zlib_acc_log.lo: zlib_acc_log.h zlib_acc_conf.h
+zlib_acc_conf.lo: zlib_acc_conf.h
diff -Naru zlib-1.2.7/zip_common.c zlib-1.2.7_new/zip_common.c
--- zlib-1.2.7/zip_common.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_common.c	2020-06-12 14:47:58.902090800 +0800
@@ -0,0 +1,733 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_common.c
+ *
+ * This file provides the common implemenation for ZIP engine dealing with wrapdrive
+ *
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <sys/types.h>
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "inflate.h"
+#include "inffast.h"
+#include "wd.h"
+#include "wd_comp.h"
+#include "smm.h"
+#include "zip_zlib.h"
+#include "zip_queue_scheduler.h"
+
+
+int get_devices_flag = 0;
+int zipdev_flag = 0;
+int get_alg_type_by_windowBits(int windowBits)
+{
+    int alg_type = Z_ERRNO;
+    if ((windowBits >= ZLIB_MIN_WBITS) && (windowBits <= ZLIB_MAX_WBITS)) {
+        alg_type = ZIP_ZLIB;
+    } else if ((windowBits >= GZIP_MIN_WBITS) && (windowBits <= GZIP_MAX_WBITS)) {
+        alg_type = ZIP_GZIP;
+    } else if ((windowBits >= DEFLATE_MIN_WBITS) && (windowBits <= DEFLATE_MAX_WBITS)) {
+        alg_type = ZIP_NONE;
+    } else {
+        alg_type = Z_ERRNO;
+    }
+    return alg_type;
+}
+
+int to_hw_alg_type(int alg_type)
+{
+    switch (alg_type) {
+        case ZIP_ZLIB:
+            return WCRYPTO_ZLIB;
+        case ZIP_GZIP:
+            return WCRYPTO_GZIP;
+        default:
+            return -1;
+    }
+}
+
+int zip_get_devices()
+{
+    DIR *uacce_dev = NULL;
+    struct dirent *device;
+    int found = 0;
+    const char* zipdev = "hisi_zip";
+    if (get_devices_flag == 0)
+    {
+        kae_debug_init_log();
+        uacce_dev = opendir("/sys/class/uacce");
+        if (!uacce_dev) {
+            US_WARN("No /sys/class/uacce directory or it cannot be opened\n");
+            return 0;
+        }
+        if (NULL != uacce_dev) {
+            while ((device = readdir(uacce_dev)) != NULL) {
+                if(strstr(device->d_name, zipdev)) {
+                    US_DEBUG("looking for dir %s\n", device->d_name);
+                    found = 1;
+                    break;
+                }
+            }
+        }       
+        closedir(uacce_dev);
+        get_devices_flag = 1;
+        if (!found) {
+            US_WARN("No running hisi_zip devices detected\n");
+            return 0;
+        }
+        return 1;
+    } else {
+        return zipdev_flag;
+    }
+}
+int zip_init(struct zip_stream *zip_strm, int alg_type, int comp_optype)
+{
+    struct wcrypto_comp_op_data *op_data = NULL;
+    struct wcrypto_paras *priv;
+    struct wd_queue *q = NULL;
+    struct wcrypto_comp_ctx_setup ctx_setup;
+    void *zip_ctx = NULL;
+    int ret = -1;
+
+    q = (struct wd_queue *)zip_malloc(sizeof(struct wd_queue));
+    if (q == NULL) {
+        US_ERR("alloc wd_queue fail!\n");
+        return Z_ERRNO;
+    }
+    memset((void *)q, 0, sizeof(struct wd_queue));
+
+    switch (alg_type) {
+        case ZIP_ZLIB:
+            ctx_setup.alg_type = WCRYPTO_ZLIB;
+            q->capa.alg = "zlib";
+            break;
+        case ZIP_GZIP:
+            ctx_setup.alg_type = WCRYPTO_GZIP;
+            q->capa.alg = "gzip";
+            break;
+        default:
+            ret = -WD_EINVAL;
+            goto queue_free;
+    }
+    q->capa.latency = 0;
+    q->capa.throughput = 0;
+    priv = (struct wcrypto_paras *)&(q->capa.priv);
+    priv->direction = comp_optype;
+    ret = wd_request_queue(q);
+    if (unlikely(ret)) {
+        US_ERR("wd_request_queue fail ret = %d\n", ret);
+        goto queue_free;
+    }
+
+    ctx_setup.stream_mode = WCRYPTO_COMP_STATEFUL;
+#ifdef CONFIG_IOMMU_SVA
+    ctx_setup.ss_buf = zip_malloc(SS_REGION_SIZE)
+#else
+    ctx_setup.ss_buf = wd_reserve_memory(q, SS_REGION_SIZE);
+#endif
+    if (unlikely(!ctx_setup.ss_buf)) {
+        ret = -WD_ENOMEM;
+        US_ERR("fail to reserve %ld dmabuf\n");
+        goto release_q;
+    }
+    ret = smm_init(ctx_setup.ss_buf, SS_REGION_SIZE, 0xF);
+    if (unlikely(ret)) {
+        US_ERR("smm_init fail ret =%d\n", ret);
+        goto buff_free;
+    }
+    ctx_setup.next_in = smm_alloc(ctx_setup.ss_buf, ASIZE);
+    ctx_setup.next_out = smm_alloc(ctx_setup.ss_buf, ASIZE);
+    ctx_setup.ctx_buf = smm_alloc(ctx_setup.ss_buf, HW_CTX_SIZE);
+    if (unlikely(!ctx_setup.next_in || !ctx_setup.next_out || !ctx_setup.ctx_buf)) {
+        ret = -WD_ENOMEM;
+        US_ERR("not enough data ss_region memory for cache (bs=%d)\n", ASIZE);
+        goto buff_free;
+    }
+    zip_ctx = wcrypto_create_comp_ctx(q, &ctx_setup);
+    if (unlikely(!zip_ctx)) {
+        ret = -WD_ENOMEM;
+        US_ERR("alloc op_data fail, ret =%d\n", ret);
+        goto buff_free;
+    }
+
+    op_data = (struct wcrypto_comp_op_data *)zip_malloc(sizeof(struct wcrypto_comp_op_data));
+    if (unlikely(op_data == NULL)) {
+        ret = -WD_ENOMEM;
+        US_ERR("alloc op_data fail, ret =%d\n", ret);
+        goto comp_ctx_free;
+    }
+    memset((void *)op_data, 0, sizeof(struct wcrypto_comp_op_data));
+
+    op_data->in = (__u8 *)ctx_setup.next_in;
+    op_data->out = (__u8 *)ctx_setup.next_out;
+    op_data->in_temp = (__u8 *)op_data->in;
+    op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW;
+    op_data->alg_type = ctx_setup.alg_type;
+    op_data->ctx = (struct wcrypto_comp_ctx_setup *)zip_ctx;
+    op_data->q = q;
+
+    zip_strm->next_in = ctx_setup.next_in;
+    zip_strm->next_out = ctx_setup.next_out;
+    zip_strm->reserved = op_data;
+    zip_strm->header_pos = 0;
+    zip_strm->windowsBits_type = alg_type;
+    zip_strm->lsb_have = 0;
+    US_DEBUG("hw_init zip_strm is %p, q is %p\n", zip_strm, q);
+
+    return Z_OK;
+
+comp_ctx_free:
+    if (zip_ctx) {
+        wcrypto_del_comp_ctx(zip_ctx);
+        zip_ctx = NULL;
+    }
+buff_free:
+#ifdef CONFIG_IOMMU_SVA
+    if (ctx_setup->ss_buff) {
+        zip_free(ctx_setup->ss_buff);
+    }
+#endif
+release_q:
+    if (q) {
+        wd_release_queue(q);
+    }
+queue_free:
+    zip_free(q);
+
+    return ret;
+}
+
+void zip_end(struct zip_stream *zip_strm)
+{
+    struct wcrypto_comp_op_data *op_data = zip_strm->reserved;
+    struct wd_queue *q = op_data->q;
+    void *zip_ctx = op_data->ctx;
+
+#ifdef CONFIG_IOMMU_SVA
+    if (op_data->ss_buf) {
+        zip_free(op_data->ss_buf);
+    }
+#endif
+    if (zip_ctx) {
+        wcrypto_del_comp_ctx(zip_ctx);
+        op_data->ctx = NULL;
+    }
+    if (q) {
+        wd_release_queue(q);
+        zip_free(q);
+    }
+    zip_free(op_data);
+
+}
+
+static unsigned int _zip_wd_bit_reverse(register unsigned int x)
+{
+    x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));
+    x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));
+    x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));
+    x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));
+
+    return ((x >> 16) | (x << 16));
+}
+
+/* output an empty store block */
+static int _zip_wd_append_store_block(struct zip_stream *zip_strm, int flush)
+{
+    struct wcrypto_comp_op_data *op_data = zip_strm->reserved;
+    char store_block[ZIP_STORE_BLOCK_SIZE] = ZIP_STORE_BLOCK;
+    __u32 checksum = op_data->checksum;
+    __u32 isize = op_data->isize;
+
+    if (op_data->stream_pos == ZIP_STREAM_END) {
+        return Z_STREAM_END;
+    }
+
+    memcpy(zip_strm->next_out, store_block, ZIP_STORE_BLOCK_SIZE);
+    zip_strm->total_out += ZIP_STORE_BLOCK_SIZE;
+    zip_strm->avail_out -= ZIP_STORE_BLOCK_SIZE;
+    zip_strm->zip_flush_have += ZIP_STORE_BLOCK_SIZE;
+
+    if (flush != WCRYPTO_FINISH) {
+        return Z_STREAM_END;
+    }
+    if (op_data->alg_type == WCRYPTO_ZLIB) { /* if zlib, ADLER32 */
+        checksum = (__u32)cpu_to_be32(checksum);
+        /* !!!zip_strm->next_out set error */
+        memcpy(zip_strm->next_out + ZIP_STORE_BLOCK_SIZE, &checksum, ZIP_CHECKSUM_SIZE);
+        zip_strm->zip_flush_have += ZIP_CHECKSUM_SIZE;
+        zip_strm->total_out += ZIP_CHECKSUM_SIZE;
+        zip_strm->avail_out -= ZIP_CHECKSUM_SIZE;
+
+    } else if (op_data->alg_type == WCRYPTO_GZIP) { /* if gzip, CRC32 and ISIZE */
+        checksum = ~checksum;
+        checksum = _zip_wd_bit_reverse(checksum);
+        memcpy(zip_strm->next_out + ZIP_STORE_BLOCK_SIZE, &checksum, ZIP_CHECKSUM_SIZE);
+        zip_strm->zip_flush_have += ZIP_CHECKSUM_SIZE;
+        zip_strm->total_out += ZIP_CHECKSUM_SIZE;
+        zip_strm->avail_out -= ZIP_CHECKSUM_SIZE;
+
+        memcpy(zip_strm->next_out + ZIP_STORE_BLOCK_SIZE + ZIP_CHECKSUM_SIZE, &isize, ZIP_GZIP_ISIZE);
+        zip_strm->zip_flush_have += ZIP_GZIP_ISIZE;
+        zip_strm->total_out += ZIP_GZIP_ISIZE;
+        zip_strm->avail_out -= ZIP_GZIP_ISIZE;
+
+    } else {
+        US_ERR("in append store block, wrong alg type %d.\n", op_data->alg_type);
+    }
+    op_data->stream_pos = ZIP_STREAM_END;
+
+    return Z_STREAM_END;
+}
+
+int zip_send_and_recv(struct zip_stream *zip_strm, int flush, int comp_optype)
+{
+    struct wcrypto_comp_op_data *op_data = zip_strm->reserved;
+    void *zip_ctx = op_data->ctx;
+    int ret = -1;
+    __u32 status = 0;
+
+
+    if (zip_strm->avail_in == 0 && flush == WCRYPTO_FINISH) {
+        if (comp_optype == WCRYPTO_DEFLATE) {
+            return _zip_wd_append_store_block(zip_strm, flush);
+        } else {
+            return Z_STREAM_END;
+        }
+    }
+    
+    op_data->flush = flush;
+    op_data->in_len = zip_strm->avail_in;
+    op_data->avail_out = zip_strm->avail_out;
+ 
+    ret = wcrypto_do_comp(zip_ctx, op_data, NULL);
+    if (unlikely(ret < 0)) {
+        US_ERR("wd_do_comp fail!\n");
+        return Z_ERRNO;
+    }
+    if (op_data->stream_pos == WCRYPTO_COMP_STREAM_NEW) {
+        op_data->stream_pos = WCRYPTO_COMP_STREAM_OLD;
+        zip_strm->total_out = 0;
+    }
+
+    if (zip_strm->avail_in >= op_data->consumed) {
+        zip_strm->avail_in -= op_data->consumed;
+    }
+    zip_strm->avail_out -=op_data->produced;
+    zip_strm->total_out +=op_data->produced;
+    zip_strm->zip_flush_have += op_data->produced;
+
+    if (zip_strm->avail_out == 0) {
+        if (zip_strm->avail_in >= op_data->consumed) {
+            op_data->in += op_data->consumed;
+        }
+    }
+    if (zip_strm->avail_out > 0) {
+        op_data->in = op_data->in_temp;
+    }
+
+    /*comp:flush == WCRYPTO_FINISH;decomp:op_data->status == WCRYPTO_DECOMP_END;DEFLATE mode inflate:crc status=64*/
+	if (flush == WCRYPTO_FINISH || op_data->status == WCRYPTO_DECOMP_END 
+        || (op_data->status == ZIP_CRC_ERR && zip_strm->windowsBits_type == ZIP_NONE)) {
+        op_data->stream_pos = ZIP_STREAM_END;
+        ret = Z_STREAM_END;
+    } else {
+		ret = Z_OK;    /* comp or decomp is_end region */
+    }
+	return ret;
+}
+
+int zip_deflate_req(z_streamp strm, int flush)
+{
+    int avail_in = 0;
+    int zip_flush = 0;
+    int ret = -1;
+
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_STREAM_ERROR;
+    }
+
+
+    avail_in = (strm->avail_in >= STREAM_CHUNK) ? STREAM_CHUNK : strm->avail_in;
+    ret = zip_put_zstream_flush(strm, avail_in);
+    if (unlikely(ret != Z_OK)) {
+        US_ERR("hw_put_flush error!\n");
+        return Z_ERRNO;
+    }
+
+    zip_strm->avail_out = STREAM_CHUNK_OUT;
+    
+    /* kae_zip only support WCRYPTO_SYNC_FLUSH and WCRYPTO_FINISH */
+    if ((!strm->avail_in) && (flush == Z_FINISH)) {
+        zip_flush = WCRYPTO_FINISH;
+    } else {
+        zip_flush = WCRYPTO_SYNC_FLUSH;
+    }
+
+    ret = zip_deflate_ex(zip_strm, zip_flush);
+    if (unlikely(ret == Z_ERRNO)) {
+        US_ERR("wd_do_comp deflate fail!\n");
+        return ret;
+    } 
+
+    ret = zip_get_zstream_flush(strm);
+
+    return ret;
+}
+
+int zip_inflate_req(z_streamp strm, int flush)
+{
+
+    int ret = -1;
+    int avail_in = 0;
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_STREAM_ERROR;
+    }
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+
+    avail_in = (strm->avail_in >= STREAM_CHUNK) ? STREAM_CHUNK : strm->avail_in;
+
+    /*when stream end but no crc*/
+    if (unlikely(op_data->status == WCRYPTO_DECOMP_NO_CRC && zip_strm->windowsBits_type == ZIP_NONE)) {
+        ret = zip_write_stream_tail(strm);
+        if (unlikely(ret != Z_OK)) {
+            US_WARN("write tail fail.");
+            return ret;
+        }
+    } else {
+        ret = zip_put_zstream_flush(strm, avail_in);
+        if (unlikely(ret != Z_OK)) {
+            return Z_ERRNO;
+        }
+    }
+    
+    /* finish compression if all of source has been read in */
+    zip_strm->avail_out = STREAM_CHUNK_OUT;
+    ret = zip_inflate_ex(zip_strm, WCRYPTO_SYNC_FLUSH);
+    /* check whether all the ZIP inbuffers are consumed and adapt to the extreme compression ratio **/
+    if (unlikely(ret == Z_ERRNO)) {
+        US_ERR("wd_do_comp inflate fail!\n");
+        return ret;
+    } else {
+        ret = zip_check_zstream_status(strm);
+        if (ret != Z_OK) {
+            return ret;
+        }
+    }
+    ret = zip_get_zstream_flush(strm);
+
+    return ret;
+}
+
+int zip_deflate_ex(struct zip_stream *zip_strm, int flush)
+{
+    return zip_send_and_recv(zip_strm, flush, WCRYPTO_DEFLATE);
+}
+
+int zip_inflate_ex(struct zip_stream *zip_strm, int flush)
+{
+    return zip_send_and_recv(zip_strm, flush, WCRYPTO_INFLATE);
+}
+
+int zip_put_zstream_flush(z_streamp strm, int avail_in)
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_ERRNO;
+    }
+    memcpy(zip_strm->next_in, strm->next_in, avail_in);
+    strm->total_in += avail_in;
+    strm->next_in += avail_in;
+    strm->avail_in -= avail_in;
+    zip_strm->avail_in = avail_in;
+
+    return Z_OK;
+}
+
+int reset_lastblk_status(z_streamp strm) 
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_ERRNO;
+    }
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+                
+    if (zip_strm->zip_flush_empty == true && op_data->stream_pos == ZIP_STREAM_END) {
+        /* last_sw_buf is not enough */
+        if (zip_strm->lsb_have == 1 && strm->avail_in == 1){
+            strm->avail_in = 0;
+            zip_strm->lsb_have = 0;
+        }
+        /* op_data->stream_pos == ZIP_STREAM_END && zip_strm->zip_flush_empty == true：reset and break while！ */
+        op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW ;
+        zip_strm->header_pos = 0;
+        return Z_STREAM_END;
+    }
+    return Z_OK;
+}
+
+int  zip_get_zstream_flush(z_streamp strm)
+{
+    static char none_zlib_tail[ZLIB_TAIL_SZ] = { 0 };
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_ERRNO;
+    }
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+    /*** The last block and zip_flush has no other data, return Z_STREAM_END***/
+    /*** The last block and zip_flush has other data, return Z_OK           ***/
+    /*** if (zip_strm->zip_flush_have = strm->avail_out) is a special scene, seemed as zip_flush_empty = false***/
+    /*** will make strm->avail_out = 0 lead unable to break out of the loop ***/
+    if (zip_strm->zip_flush_have < strm->avail_out) {
+        memcpy(strm->next_out, zip_strm->next_out + zip_strm->zip_flush_offset, zip_strm->zip_flush_have);
+        strm->next_out += zip_strm->zip_flush_have;
+        strm->total_out += zip_strm->zip_flush_have;
+        strm->avail_out -= zip_strm->zip_flush_have;
+        zip_strm->zip_flush_empty = true;
+        zip_strm->zip_flush_have = 0;
+        zip_strm->zip_flush_offset = 0;
+        if (op_data->stream_pos == ZIP_STREAM_END) {
+            /* final block and the work is deflate*/
+            if ((op_data->status != ZIP_CRC_ERR) && (op_data->status != WCRYPTO_DECOMP_END) 
+                && (zip_strm->windowsBits_type == ZIP_NONE)) {
+                if (strm->total_out >= ZLIB_TAIL_SZ) {
+                    strm->total_out -= ZLIB_TAIL_SZ;
+                    strm->avail_out += ZLIB_TAIL_SZ;
+                } else {
+                    return Z_ERRNO;
+                }
+            }
+            /* last_sw_buf is not enough */
+            if (zip_strm->lsb_have == 1 && strm->avail_in == 1){
+                strm->avail_in = 0;
+                zip_strm->lsb_have = 0;
+            }
+            /* op_data->stream_pos == ZIP_STREAM_END && zip_strm->zip_flush_empty == true：reset and break while！ */
+            op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW;
+            zip_strm->header_pos = 0;
+            return Z_STREAM_END;
+        } else {
+            return Z_OK;
+        }
+    } else {
+        memcpy(strm->next_out, zip_strm->next_out + zip_strm->zip_flush_offset, strm->avail_out);
+        strm->next_out += strm->avail_out;
+        strm->total_out += strm->avail_out;
+        zip_strm->zip_flush_offset += strm->avail_out;
+        zip_strm->zip_flush_have -= strm->avail_out;
+        strm->avail_out = 0;
+        /* when last soft buf is not enough and avain_in == 0, set avain_in = 1 */
+
+        if (op_data->stream_pos == ZIP_STREAM_END && strm->avail_in == 0) {
+            zip_strm->lsb_have = 1;
+            strm->avail_in = 1;
+        }
+        if (zip_strm->zip_flush_have == strm->avail_out) { 
+            zip_strm->zip_flush_empty = true;
+            zip_strm->zip_flush_have = 0;
+            zip_strm->zip_flush_offset = 0;
+            return reset_lastblk_status(strm);
+        } else {
+            zip_strm->zip_flush_empty = false;
+            return Z_OK;
+        }   
+    }
+}
+
+const char zlib_head[ZLIB_HEADER_SZ] = ZLIB_HEADER;
+const char zlib_tail[ZLIB_TAIL_SZ] = ZLIB_TAIL;
+const char gzip_head[GZIP_HEADER_SZ] = GZIP_HEADER;
+
+int zip_write_stream_header(z_streamp strm, int alg_type)
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+
+    if (alg_type == WCRYPTO_ZLIB) {
+        if (strm->avail_out >= (ZLIB_HEADER_SZ - zip_strm->header_pos)) {
+            memcpy(strm->next_out, zlib_head + zip_strm->header_pos, (ZLIB_HEADER_SZ - zip_strm->header_pos));
+            strm->next_out += (ZLIB_HEADER_SZ - zip_strm->header_pos);
+            strm->total_out += (ZLIB_HEADER_SZ - zip_strm->header_pos);
+            strm->avail_out -= (ZLIB_HEADER_SZ - zip_strm->header_pos);
+            zip_strm->header_pos = -1;
+        } else {
+            memcpy(strm->next_out, zlib_head + zip_strm->header_pos, strm->avail_out);
+            strm->next_out += strm->avail_out;
+            strm->total_out += strm->avail_out;
+            zip_strm->header_pos += strm->avail_out;
+            strm->avail_out = 0;
+            return Z_ERRNO;
+        }
+    } else {
+        if (strm->avail_out >= (GZIP_HEADER_SZ - zip_strm->header_pos)) {
+            memcpy(strm->next_out, gzip_head + zip_strm->header_pos, (GZIP_HEADER_SZ - zip_strm->header_pos));
+            strm->next_out += (GZIP_HEADER_SZ - zip_strm->header_pos);
+            strm->total_out += (GZIP_HEADER_SZ - zip_strm->header_pos);
+            strm->avail_out -= (GZIP_HEADER_SZ - zip_strm->header_pos);
+            zip_strm->header_pos = -1;
+        } else {
+            memcpy(strm->next_out, gzip_head + zip_strm->header_pos, strm->avail_out);
+            strm->next_out += strm->avail_out;
+            strm->total_out += strm->avail_out;
+            zip_strm->header_pos += strm->avail_out;
+            strm->avail_out = 0;
+            return Z_ERRNO;
+        }
+    }
+    return Z_OK;
+}
+
+int zip_write_stream_tail(z_streamp strm)
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    if (strm->avail_in == 0 ) {
+        memcpy(zip_strm->next_in, zlib_tail, ZLIB_TAIL_SZ);
+            zip_strm->avail_in += ZLIB_TAIL_SZ;
+            return Z_OK;
+        } else {
+            return Z_ERRNO;
+    }
+}
+
+int zip_check_zstream_status(z_streamp strm)
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_STREAM_ERROR;
+    }
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+    /*** wd_queue avail_in not = 0 sw_stream back***/
+    if (zip_strm->avail_in > 0) {
+        strm->next_in = strm->next_in - zip_strm->avail_in;
+        strm->avail_in += zip_strm->avail_in;
+        strm->total_in -= zip_strm->avail_in;
+        zip_strm->avail_in = 0;
+    }
+    return Z_OK;
+}
+
+int zip_get_stream_header(z_streamp strm, int alg_type)
+{
+    static char zlib_head_t[ZLIB_HEADER_SZ] = { 0 };
+    static char gzip_head_t[GZIP_HEADER_SZ] = { 0 };
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_ERRNO;
+    }
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+    /***get and diff header***/
+    if (op_data->stream_pos == WCRYPTO_COMP_STREAM_NEW) {
+        if (alg_type == WCRYPTO_ZLIB) {
+            if (strm->avail_in >= (ZLIB_HEADER_SZ - zip_strm->header_pos)) {
+                memcpy(zlib_head_t + zip_strm->header_pos, strm->next_in, (ZLIB_HEADER_SZ - zip_strm->header_pos));
+                strm->next_in += (ZLIB_HEADER_SZ - zip_strm->header_pos);
+                strm->avail_in -= (ZLIB_HEADER_SZ - zip_strm->header_pos);
+                strm->total_in += (ZLIB_HEADER_SZ - zip_strm->header_pos);
+                zip_strm->header_pos = -1;
+            } else {
+                memcpy(zlib_head_t + zip_strm->header_pos, strm->next_in, strm->avail_in);
+                strm->next_in += strm->avail_in;
+                strm->total_in += strm->avail_in;
+                zip_strm->header_pos += strm->avail_in;
+                strm->avail_in = 0;
+
+                return Z_ERRNO;
+            }
+        } else {
+            if (strm->avail_in >= (GZIP_HEADER_SZ - zip_strm->header_pos)) {
+                memcpy(gzip_head_t + zip_strm->header_pos, strm->next_in, (GZIP_HEADER_SZ - zip_strm->header_pos));
+                strm->next_in += (GZIP_HEADER_SZ - zip_strm->header_pos);
+                strm->total_in = (GZIP_HEADER_SZ - zip_strm->header_pos);
+                strm->avail_in -= (GZIP_HEADER_SZ - zip_strm->header_pos);
+                zip_strm->header_pos = -1;
+
+            } else {
+                memcpy(gzip_head_t + zip_strm->header_pos, strm->next_in, strm->avail_in);
+                strm->next_in += strm->avail_in;
+                strm->total_in = strm->avail_in;
+                zip_strm->header_pos += strm->avail_in;
+                strm->avail_in = 0;
+
+                return Z_ERRNO;
+            }
+        }
+    }
+
+    if (strm->avail_in == 0) {
+        return Z_ERRNO;
+    }
+
+    return Z_OK;
+}
+
+inline unsigned int zip_get_thread_id()
+{
+    return pthread_self();
+}
+
+long zip_get_cur_time()
+{
+    struct timeval tv;
+
+    gettimeofday(&tv, NULL);
+
+    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
+}
+
+inline void *zip_malloc(unsigned int size)
+{
+    return malloc(size);
+}
diff -Naru zlib-1.2.7/zip_common.h zlib-1.2.7_new/zip_common.h
--- zlib-1.2.7/zip_common.h	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_common.h	2020-06-12 14:47:58.903590900 +0800
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_common.h
+ *
+ * This file provides the common interface for ZIP engine dealing with wrapdrive
+ *
+ *****************************************************************************/
+
+#ifndef ZIP_COMMON_H
+#define ZIP_COMMON_H
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define likely(x)   __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+
+#define ZIP_QUEUE_SIZE 600
+#define TIME_THRESHOLD 60000
+
+#define PAGE_SHIFT 12
+#define PAGE_SIZE  (1 << PAGE_SHIFT)
+
+#define ASIZE          (1024 * 1024)
+#define SS_REGION_SIZE (4096 + ASIZE * 2 + HW_CTX_SIZE)
+
+#define ZIP_ZLIB 0
+#define ZIP_GZIP 1
+#define ZIP_NONE 2
+
+#define HW_CTX_SIZE   (64 * 1024)
+#define WD_RECV_TIMES 200000000
+
+#define ZIP_STREAM_END 2
+#define ZIP_CRC_ERR 64
+
+#define STREAM_CHUNK     (1024 * 128)
+#define STREAM_CHUNK_OUT (1024 * 1024)
+
+#define swab32(x)                 \
+    ((((x)&0x000000ff) << 24) |  \
+        (((x)&0x0000ff00) << 8) |  \
+        (((x)&0x00ff0000) >> 8) |  \
+        (((x)&0xff000000) >> 24))
+
+#define cpu_to_be32(x)       swab32(x)
+#define ZIP_STORE_BLOCK_SIZE 5
+#define ZIP_STORE_BLOCK      "\x01\x00\x00\x0FF\xFF"
+#define ZIP_CHECKSUM_SIZE    4
+#define ZIP_GZIP_ISIZE       4
+
+extern int get_devices_flag;
+extern int zipdev_flag;
+struct zip_stream {
+    void *next_in;           /* next input byte */
+    unsigned long avail_in;  /* number of bytes available at next_in */
+    unsigned long total_in;  /* total nb of input bytes read so far */
+    void *next_out;          /* next output byte should be put there */
+    unsigned long avail_out; /* remaining free space at next_out */
+    unsigned long total_out; /* total nb of bytes output so far */
+    char *msg;               /* last error message, NULL if no error */
+    void *workspace;         /* memory allocated for this stream */
+    int data_type;           /* the data type: ascii or binary */
+    unsigned long adler;     /* adler32 value of the uncompressed data */
+    void *reserved;          /* used for *opdata */
+    int zip_flush_offset;
+    int zip_flush_have;
+    int zip_flush_empty;
+    unsigned int tid;
+    long time_stamp;
+    bool doing_flag;
+    int header_pos;
+    int windowsBits_type;    /* used for DEFLATE mode:ZIP_NONE mode will extra hendle */
+    int lsb_have;            /* used for last block:the soft buf is not enough */
+};
+typedef struct zip_stream *zip_streamp;
+
+#define ZLIB_HEADER     "\x78\x9c"
+#define ZLIB_HEADER_CHK 0x78
+#define ZLIB_HEADER_SZ  2
+#define ZLIB_TAIL     "\xaa\xaa\xaa\xaa"
+#define ZLIB_TAIL_SZ   4
+
+#define GZIP_HEADER    "\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03"
+#define GZIP_HEADER_SZ 10
+#define GZIP_EXTRA_SZ  10
+#define GZIP_TAIL_SZ   8
+
+
+#ifndef DEBUG_LOG
+#include "zlib_acc_log.h"
+
+#else
+#include <syslog.h>
+
+#define US_ERR(fmt, args...) \
+    syslog(LOG_USER | LOG_ERR, "([ZIP] ERR) %s %s %d: " fmt "\n", __FILE__, __FUNCTION__, __LINE__, ##args)
+
+#define US_DEBUG(fmt, args...) \
+    syslog(LOG_USER | LOG_DEBUG, "([ZIP] DEBUG) %s %s %d: " fmt "\n", __FILE__, __FUNCTION__, __LINE__, ##args)
+
+#define US_WARN(fmt, args...) \
+    syslog(LOG_USER | LOG_WARNING, "([ZIP] WARN) %s %s %d: " fmt "\n", __FILE__, __FUNCTION__, __LINE__, ##args)
+
+#define US_INFO(fmt, args...) \
+    syslog(LOG_USER | LOG_INFO, "([ZIP] INFO) %s %s %d: " fmt "\n", __FILE__, __FUNCTION__, __LINE__, ##args)
+
+#endif
+enum ZIP_BD_STATUS {
+    ZIP_BD_OK = 0x00,
+    ZIP_BD_INPUT_DATA_LENGTH_ERROR,
+    ZIP_BD_DESTIN_AVAIL_OUT_ERROR,
+    ZIP_BD_REQUEST_TYPE_ERROR,
+    ZIP_BD_BUF_TYPE_ERROR,
+    ZIP_BD_GEN_PAGE_PAD_CTRL_ERROR,
+    ZIP_BD_GEN_GRD_CTRL_ERROR,
+    ZIP_BD_GEN_VER_CTRL_ERROR,
+    ZIP_BD_GEN_APP_CTRL_ERROR,
+    ZIP_BD_GEN_REF_CTRL_ERROR,
+    ZIP_BD_CHK_GRD_CTRL_ERROR,
+    ZIP_BD_CHK_ERF_CTRL_ERROR,
+    ZIP_BD_PAGE_PAD_TYPE_ERROR,
+    ZIP_BD_NEGATIVE_COMPRESS,
+    ZIP_BD_NO_DESTIN_AVAIL_OUT,
+    ZIP_BD_IN_DIFF_ERROR,
+    ZIP_BD_DEF_CRC_ERROR,
+    ZIP_BD_DEF_BLOCK_SIZE_ERROR,
+    ZIP_BD_DEF_DIFF_ERROR,
+    ZIP_BD_STREAM_END,
+    ZIP_BD_IN_COMP_DATA_ALIGN_SIZE_ERROR,
+    ZIP_BD_IN_BLOCK_SIZE_ERROR,
+};
+
+#define zip_free(addr)      \
+    do {                    \
+        if (addr != NULL) { \
+            free(addr);     \
+            addr = NULL;    \
+        }                   \
+    } while (0)
+
+int zip_get_devices();
+int zip_init(struct zip_stream *zstrm, int alg_type, int comp_optype);
+void zip_end(struct zip_stream *zstrm);
+int zip_inflate_ex(struct zip_stream *zstrm, int flush);
+unsigned int zip_get_thread_id();
+int zip_send_and_recv(struct zip_stream *zstrm, int flush, int comp_optype);
+int zip_deflate_ex(struct zip_stream *zstrm, int flush);
+int zip_inflate_ex(struct zip_stream *zstrm, int flush);
+int zip_put_zstream_flush(z_streamp strm, int avail_in);
+int reset_lastblk_status(z_streamp strm);
+int zip_get_zstream_flush(z_streamp strm);
+int zip_write_stream_header(z_streamp strm, int alg_type);
+int zip_write_stream_tail(z_streamp strm);
+int zip_check_zstream_status(z_streamp strm);
+int zip_get_stream_header(z_streamp strm, int alg_type);
+long zip_get_cur_time();
+int zip_deflate_req(z_streamp strm, int flush);
+int zip_inflate_req(z_streamp strm, int flush);
+void *zip_malloc(unsigned int size);
+
+int get_alg_type_by_windowBits(int windowBits);
+
+int to_hw_alg_type(int alg_type);
+
+#endif
+
+
diff -Naru zlib-1.2.7/zip_deflate.c zlib-1.2.7_new/zip_deflate.c
--- zlib-1.2.7/zip_deflate.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_deflate.c	2020-06-12 14:52:55.283726400 +0800
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_deflate.c
+ *
+ * This file provides the Interface for zlib;
+ *
+ *****************************************************************************/
+
+#include "zip_zlib.h"
+#include "zip_common.h"
+#include "zip_queue_scheduler.h"
+#include "wd.h"
+#include "wd_comp.h"
+//#include "zip_usr_if.h"
+
+
+
+static struct zstrm_pool g_zip_deflate_pool = 
+{
+    .pool_size = 0,
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+};
+
+/******************************************************************************
+* function:
+*int zip_deflateInit2_(z_streamp strm, int level,
+*                     int method, int windowBits,
+*                     int memLevel, int strategy,
+*                     const char *version,
+*                     int stream_size)
+*   
+******************************************************************************/
+
+int zip_deflateInit2_(z_streamp strm, int level,
+                      int method, int windowBits,
+                      int memLevel, int strategy,
+                      const char *version,
+                      int stream_size)
+{
+    int ret = 1;
+    unsigned int tid = 0;
+    zip_streamp zip_strm = NULL;
+    int alg_type = Z_ERRNO;
+    struct wcrypto_comp_op_data *op_data = NULL;
+    ret = sw_deflateInit2_(strm, level, method, windowBits, memLevel, strategy, version, stream_size);
+
+    if (ret != Z_OK) {
+        return Z_ERRNO;
+    }
+
+    tid = zip_get_thread_id();
+    zip_strm = zip_sched_get_queue(&g_zip_deflate_pool, tid);
+    zip_sched_release_queue(&g_zip_deflate_pool);
+
+    alg_type = get_alg_type_by_windowBits(windowBits);
+    if (!zip_strm) {
+        zip_strm = (zip_streamp)zip_malloc(sizeof(struct zip_stream));
+        if (zip_strm == NULL) {
+            US_ERR("zip_strm error!\n");
+            return Z_ERRNO;
+        }
+        memset(zip_strm, 0, sizeof(struct zip_stream));
+
+        if (unlikely(alg_type != Z_ERRNO)) {
+            ret = zip_init(zip_strm, alg_type, WCRYPTO_DEFLATE);
+        } else {
+            US_ERR("windowBits set error!\n");
+            ret = Z_ERRNO;
+        }
+        
+        if (unlikely(ret != Z_OK)) {
+            zip_sched_release_spec_queue(&g_zip_deflate_pool, zip_strm);
+            zip_strm = NULL;            
+            strm->reserved = 0;
+            US_ERR(" zip init failed, change sw, ret is %d\n", ret);
+            return Z_OK;
+        }
+        op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+        if (unlikely(op_data == NULL)) {
+            US_ERR("op_data error!\n");
+            return Z_ERRNO;
+        }
+        ret = zip_sched_put_queue(&g_zip_deflate_pool, zip_strm, tid);
+        if (unlikely(ret != Z_OK)) {
+            US_ERR(" hw_put_queue fail!\n");
+        }
+    } else {
+        op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+        if (unlikely(op_data == NULL)) {
+            US_ERR("op_data error!\n");
+            return Z_ERRNO;
+        }
+        if(unlikely(op_data->alg_type != to_hw_alg_type(alg_type))) {       
+            zip_end(zip_strm);  
+            if (likely(alg_type != Z_ERRNO)) {
+                ret = zip_init(zip_strm, alg_type, WCRYPTO_DEFLATE);
+            } else {
+                US_ERR("windowBits set error!\n");
+                ret = Z_ERRNO;
+            }
+            
+            if (unlikely(ret != Z_OK)) {
+                zip_sched_release_spec_queue(&g_zip_deflate_pool, zip_strm);
+                zip_strm = NULL;                
+                strm->reserved = 0;
+                US_ERR(" zip init failed, change sw, ret is %d\n", ret);
+                return Z_OK;
+            }
+            op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+            if (unlikely(op_data == NULL)) {
+                US_ERR("op_data error!\n");
+                return Z_ERRNO;
+            }
+            ret = zip_sched_put_queue(&g_zip_deflate_pool, zip_strm, tid);
+            if (unlikely(ret != Z_OK)) {
+                US_ERR(" hw_put_queue fail!\n");
+            }
+        }
+    }
+    
+    op_data->stream_pos =WCRYPTO_COMP_STREAM_NEW;
+    zip_strm->zip_flush_empty = true;
+    zip_strm->zip_flush_offset = 0;
+    zip_strm->zip_flush_have = 0;
+    strm->reserved = (uLong)zip_strm;
+    zip_strm->header_pos = 0;
+
+    return ret;
+}
+
+/******************************************************************************
+* function:
+* int zip_deflate(z_streamp strm, int flush)
+*
+*
+* @param   [IN] - 
+* @param   [IN] -
+*
+* description:
+*   
+******************************************************************************/
+
+int zip_deflate(z_streamp strm, int flush)
+{
+    int ret = -1;
+    struct wcrypto_comp_op_data *op_data = NULL;
+
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("zip_strm error!\n");
+        return Z_ERRNO;
+    }
+    op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(op_data == NULL)) {
+        US_ERR("op_data error!\n");
+        return Z_ERRNO;
+    }
+    if ((op_data->stream_pos ==WCRYPTO_COMP_STREAM_NEW) && (strm->avail_in == 0)) {
+        return Z_STREAM_END;
+    }
+
+    /****** add zlib compress head and write head + compressed date to a file ******/
+    if (op_data->stream_pos ==WCRYPTO_COMP_STREAM_NEW && zip_strm->header_pos != -1) {
+        if(zip_strm->windowsBits_type != ZIP_NONE) {
+            ret = zip_write_stream_header(strm, op_data->alg_type);
+            if (unlikely(ret != Z_OK)) {
+                US_WARN("should still write header.");
+                return Z_OK;
+            }
+        } else {
+            zip_strm->header_pos = -1;
+        }
+    }
+
+    if (strm->avail_in == 0 && flush != Z_FINISH && zip_strm->zip_flush_empty == true) {
+        US_WARN("warning, no more input stream, it should be flush end.");
+        return Z_BUF_ERROR;
+    }
+
+    if (strm->avail_out == 0 && flush == Z_FINISH && zip_strm->zip_flush_empty == false) {
+        US_WARN("no enough output buffer, it should be buffer error.");
+        return Z_BUF_ERROR;
+    }
+
+    /************copy data to zip engine and do deflate until************
+     ************strm->avail_out == 0 or strm->avali_in == 0 ************/
+    do {
+        if (zip_strm->zip_flush_empty == true) {
+            if(op_data->stream_pos != ZIP_STREAM_END) {
+                ret = zip_deflate_req(strm, flush);
+            } else  {
+                ret = reset_lastblk_status(strm);
+                break;
+            }
+        } else {
+            ret = zip_get_zstream_flush(strm);
+        }
+    } while ((strm->avail_out != 0) && (strm->avail_in != 0));
+    /************ stream will be complete ************/
+    if (op_data->status == WD_VERIFY_ERR) {
+        return Z_DATA_ERROR;
+    }
+    if (unlikely(ret == Z_ERRNO)) {
+        US_ERR("ERROR inflate_zip ret is %d\n", ret);
+        return Z_STREAM_ERROR;
+    } else {
+        return ret;
+    }
+}
+
+/******************************************************************************
+* function:
+* zip_deflateEnd(z_streamp strm)
+*
+*
+* @param   [IN] - 
+* @param   [IN] -
+*
+* description:
+*   
+******************************************************************************/
+
+int zip_deflateEnd(z_streamp strm)
+{
+    if (strm->reserved != 0) {
+        ((struct zip_stream *)strm->reserved)->doing_flag = false;
+        US_WARN("deflateEnd_HW! ");
+
+    } else {
+        US_WARN("deflateEnd_SW! ");
+    }
+    return sw_deflateEnd(strm);
+}
+
diff -Naru zlib-1.2.7/zip_inflate.c zlib-1.2.7_new/zip_inflate.c
--- zlib-1.2.7/zip_inflate.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_inflate.c	2020-06-12 14:53:21.345035800 +0800
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_inflate.c
+ *
+ * This file provides the Interface for zlib;
+ *
+ *****************************************************************************/
+#include "zip_zlib.h"
+#include "zip_common.h"
+#include "zip_queue_scheduler.h"
+#include "wd.h"
+#include "wd_comp.h"
+
+
+
+static struct zstrm_pool g_zip_inflate_pool = {
+    .pool_size = 0,
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+};
+
+int ZEXPORT zip_inflateReset(z_streamp strm)
+{
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(!zip_strm)) {
+        US_ERR("hw_inflate alloc zip_strm fail!\n");
+        return Z_STREAM_ERROR;
+    }
+    if (unlikely(!op_data)) {
+        US_ERR("hw_inflate alloc op_data fail!\n");
+        return Z_ERRNO;
+    }
+
+    op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW;
+    zip_strm->zip_flush_empty = true;
+    zip_strm->zip_flush_offset = 0;
+    zip_strm->zip_flush_have = 0;
+    zip_strm->header_pos = 0;
+    zip_strm->avail_in = 0;
+    strm->reserved = (uLong)zip_strm;
+
+    US_DEBUG("[zip] zip reset sucessed!! \n");
+
+    return sw_inflateReset(strm);
+}
+
+int ZEXPORT zip_inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
+{
+    int ret = -1;
+    unsigned int tid = 0;
+    zip_streamp zip_strm = NULL;
+    int alg_type = Z_ERRNO;
+    struct wcrypto_comp_op_data *op_data = NULL;
+
+    ret = sw_inflateInit2_(strm, windowBits, version, stream_size);
+    if (unlikely(ret != Z_OK)) {
+        US_ERR("inflateInit2_sw_ error!\n");
+        return Z_ERRNO;
+    }
+
+    tid = zip_get_thread_id();
+    zip_strm = zip_sched_get_queue(&g_zip_inflate_pool, tid);
+    zip_sched_release_queue(&g_zip_inflate_pool);
+
+    alg_type = get_alg_type_by_windowBits(windowBits);
+    if (!zip_strm) {
+        zip_strm = (zip_streamp)zip_malloc(sizeof(struct zip_stream));
+        if (unlikely(zip_strm == NULL)) {
+            US_ERR("inflateInit2_zip_ alloc zip_strm fail!\n");
+            return Z_ERRNO;
+        }
+        memset(zip_strm, 0, sizeof(struct zip_stream));
+
+        if (likely(alg_type != Z_ERRNO)) {
+            ret = zip_init(zip_strm, alg_type, WCRYPTO_INFLATE);
+        } else {
+            US_ERR("windowBits set error!\n");
+            ret = Z_ERRNO;
+        }
+
+        if (unlikely(ret != Z_OK)) {
+            zip_sched_release_spec_queue(&g_zip_inflate_pool, zip_strm);
+            zip_strm = NULL;
+            strm->reserved = 0;
+            US_ERR(" zip init failed, change sw, ret is %d\n", ret);
+            return Z_OK;
+        }
+        op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+        if (unlikely(!op_data)) {
+            US_ERR("op_data error!\n");
+            return Z_ERRNO;
+        }
+        ret = zip_sched_put_queue(&g_zip_inflate_pool, zip_strm, tid);
+        if (unlikely(ret != Z_OK)) {
+            US_ERR(" hw_put_queue fail!\n");
+        }
+    } else {
+        op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+        if (unlikely(!op_data)) {
+            US_ERR("op_data error!\n");
+            return Z_ERRNO;
+        }
+        if(unlikely(op_data->alg_type != to_hw_alg_type(alg_type))) {
+            zip_end(zip_strm);
+            if (likely(alg_type != Z_ERRNO)) {
+                ret = zip_init(zip_strm, alg_type, WCRYPTO_INFLATE);
+            } else {
+                US_ERR("windowBits set error!\n");
+                ret = Z_ERRNO;
+            }        
+            if (unlikely(ret != Z_OK)) {
+                US_ERR(" zip init failed, change sw, ret is %d\n", ret);
+                zip_sched_release_spec_queue(&g_zip_inflate_pool, zip_strm);
+                zip_strm = NULL;
+                strm->reserved = 0;
+                return Z_OK;
+            }
+            op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+            if (unlikely(!op_data)) {
+                US_ERR("op_data error!\n");
+                return Z_ERRNO;
+            }
+            ret = zip_sched_put_queue(&g_zip_inflate_pool, zip_strm, tid);
+            if (unlikely(ret != Z_OK)) {
+                US_ERR(" hw_put_queue fail!\n");
+            }
+        }
+    }
+    op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW;
+    zip_strm->zip_flush_empty = true;
+    zip_strm->zip_flush_offset = 0;
+    zip_strm->zip_flush_have = 0;
+    zip_strm->header_pos = 0;
+    zip_strm->avail_in = 0;
+    strm->reserved = (uLong)zip_strm;
+    US_DEBUG("[zip] zip_inflate init sucessed!! \n");
+
+    return ret;
+}
+
+int ZEXPORT zip_inflate(z_streamp strm, int flush)
+{
+    int ret = -1;
+    int mode_deal_flag = false;
+    struct zip_stream *zip_strm = (struct zip_stream *)strm->reserved;
+    struct wcrypto_comp_op_data *op_data = (struct wcrypto_comp_op_data *)zip_strm->reserved;
+    if (unlikely(zip_strm == NULL)) {
+        US_ERR("hw_inflate alloc zip_strm fail!\n");
+        return Z_STREAM_ERROR;
+    }
+    if (unlikely(op_data == NULL)) {
+        US_ERR("hw_inflate alloc op_data fail!\n");
+        return Z_ERRNO;
+    }
+    if ((op_data->stream_pos == WCRYPTO_COMP_STREAM_NEW) && (strm->avail_in == 0)) {
+        return Z_STREAM_END;
+    }
+
+    if (op_data->stream_pos == WCRYPTO_COMP_STREAM_NEW && zip_strm->header_pos != -1) {
+        if(zip_strm->windowsBits_type != ZIP_NONE) {
+            ret = zip_get_stream_header(strm, op_data->alg_type);
+            if (unlikely(ret != Z_OK)) {
+                US_WARN("should still get header.");
+                return Z_OK;
+            }
+        } 
+    }
+
+    if (strm->avail_in == 0 && flush != Z_FINISH && zip_strm->zip_flush_empty == true) {
+        return Z_BUF_ERROR;
+    }
+    /****get inflate from zip_flush****/
+    do {
+        /* do inflate work*/
+        if (zip_strm->zip_flush_empty == true ) {
+            if(op_data->stream_pos != ZIP_STREAM_END) {
+                ret = zip_inflate_req(strm, flush);
+            } else  {
+                ret = reset_lastblk_status(strm);
+                break;
+            }
+
+        } else {
+            ret = zip_get_zstream_flush(strm);
+        }
+
+        /* deal with NOSPACE mode status*/
+        if (op_data->status == WCRYPTO_DECOMP_END_NOSPACE) {
+            mode_deal_flag = true;
+        } else {
+            mode_deal_flag = false;
+        }
+        if (strm->avail_in == 0 && mode_deal_flag == false) {
+            break;
+        }
+        if (ret == Z_STREAM_END) {
+            /* last_sw_buf is not enough */
+            if (zip_strm->lsb_have == 1 && strm->avail_in == 1){
+                strm->avail_in = 0;
+                zip_strm->lsb_have = 0;
+            }
+            /* op_data->stream_pos == ZIP_STREAM_END && zip_strm->zip_flush_empty == true：reset and break while！ */
+            op_data->stream_pos = WCRYPTO_COMP_STREAM_NEW;
+            zip_strm->header_pos = 0;
+            break;
+        }
+    } while (strm->avail_out != 0);
+   
+    if (op_data->status == WD_VERIFY_ERR) {
+        return Z_DATA_ERROR;
+    }
+    if (unlikely(ret == Z_ERRNO)) {
+        US_ERR("ERROR inflate_zip ret is %d\n", ret);
+        return Z_STREAM_ERROR;
+    } else {
+        return ret;
+    }
+}
+
+int ZEXPORT zip_inflateSync(z_streamp strm)
+{
+    int ret = -1;
+    ret = zip_inflate(strm, Z_NO_FLUSH);
+    if (ret != Z_STREAM_ERROR) {
+        return Z_OK;
+    } else {
+        return ret;
+    }
+}
+
+int zip_inflateEnd(z_streamp strm)
+{
+    if (strm->reserved != 0) {
+        ((struct zip_stream *)strm->reserved)->doing_flag = false;
+        US_DEBUG("inflateEnd HW! ");
+    } else {
+        US_DEBUG("inflateEnd SW! ");
+    }
+
+    return sw_inflateEnd(strm);
+}
diff -Naru zlib-1.2.7/zip_queue_scheduler.c zlib-1.2.7_new/zip_queue_scheduler.c
--- zlib-1.2.7/zip_queue_scheduler.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_queue_scheduler.c	2020-06-12 14:47:58.908591600 +0800
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_queue_scheduler.c
+ *
+ * This file provides the queue scheduler for zlib;
+ *
+ *****************************************************************************/
+#include "zip_zlib.h"
+#include "zip_queue_scheduler.h"
+
+zip_streamp zip_sched_get_queue(zstrm_poolp hw_queue_poolp, unsigned int tid)
+{
+    int i = 0;
+
+    for (i; i < hw_queue_poolp->pool_size; i++) {
+        if (false == __sync_lock_test_and_set(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag), true)) {
+            if (hw_queue_poolp->hw_zstrm_queue[i].zstrm) {
+                if ((hw_queue_poolp->hw_zstrm_queue[i].zstrm->doing_flag == false)) {
+                    hw_queue_poolp->hw_zstrm_queue[i].zstrm->doing_flag = true;
+                    hw_queue_poolp->hw_zstrm_queue[i].zstrm->time_stamp = zip_get_cur_time();
+                    __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+                    US_DEBUG("hw_get_queue, tid is%d,zstrm id is %d\n", tid, i);
+                    return hw_queue_poolp->hw_zstrm_queue[i].zstrm;
+                }
+            }
+            __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+        }
+    }
+    US_DEBUG("hw_get_queue none, tid is %d\n", tid);
+
+    return NULL;
+}
+
+static void zip_sched_set_pool_size(zstrm_poolp hw_queue_poolp, int set_num)
+{
+    pthread_mutex_lock(&(hw_queue_poolp->mutex));
+    if (set_num > hw_queue_poolp->pool_size) {
+        hw_queue_poolp->pool_size = set_num;
+    }
+    (void)pthread_mutex_unlock(&(hw_queue_poolp->mutex));
+}
+
+int zip_sched_put_queue(zstrm_poolp hw_queue_poolp, zip_streamp zstrm, unsigned int tid)
+{
+    int i = 0;
+
+    for (i; i < ZIP_QUEUE_SIZE; i++) {
+        if (false == __sync_lock_test_and_set(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag), true)) {
+            if (!hw_queue_poolp->hw_zstrm_queue[i].zstrm) {
+                zstrm->doing_flag = true;
+                zstrm->tid = tid;
+                zstrm->time_stamp = zip_get_cur_time();
+                hw_queue_poolp->hw_zstrm_queue[i].zstrm = zstrm;
+                if(hw_queue_poolp->pool_size <= i) {
+                    zip_sched_set_pool_size(hw_queue_poolp, i + 1);
+                }
+                US_DEBUG("hw_put_queue, tid is%d, zstrm id is %d\n", tid, i);
+                __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+                return Z_OK;
+            }
+            __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+        }
+    }
+
+    return Z_ERRNO;
+}
+
+void zip_sched_release_spec_queue(zstrm_poolp hw_queue_poolp, zip_streamp zstrm)
+{
+    int i = 0;
+    zip_streamp z_stream = NULL;
+
+    for (i; i < hw_queue_poolp->pool_size; i++) {
+        if (false == __sync_lock_test_and_set(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag), true)) {
+            z_stream = hw_queue_poolp->hw_zstrm_queue[i].zstrm;
+            if (z_stream == zstrm) {
+                    if (z_stream) {
+                        zip_free(z_stream);
+                        hw_queue_poolp->hw_zstrm_queue[i].zstrm = NULL;
+                    }
+                    US_DEBUG("release one queue\n");
+            }
+            __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+        }
+    }
+}
+
+void zip_sched_release_queue(zstrm_poolp hw_queue_poolp)
+{
+    int i = 0;
+    long c_time = 0;
+    long time_threshold = 0;
+    zip_streamp z_stream = NULL;
+
+    for (i; i < hw_queue_poolp->pool_size; i++) {
+        if (false == __sync_lock_test_and_set(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag), true)) {
+            z_stream = hw_queue_poolp->hw_zstrm_queue[i].zstrm;
+            if (z_stream) {
+                c_time = zip_get_cur_time();
+                time_threshold = c_time - z_stream->time_stamp;
+                if ((time_threshold > TIME_THRESHOLD) && (z_stream->doing_flag == false)) {
+                    hw_queue_poolp->hw_zstrm_queue[i].zstrm = NULL;
+                    zip_end(z_stream);
+                    if (z_stream) {
+                        zip_free(z_stream);
+                        z_stream = NULL;
+                    }
+                    US_DEBUG("release one queue\n");
+                }
+            }
+            __sync_lock_release(&(hw_queue_poolp->hw_zstrm_queue[i].using_flag));
+        }
+    }
+}
+
diff -Naru zlib-1.2.7/zip_queue_scheduler.h zlib-1.2.7_new/zip_queue_scheduler.h
--- zlib-1.2.7/zip_queue_scheduler.h	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_queue_scheduler.h	2020-06-12 14:47:58.909591700 +0800
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_queue_scheduler.h
+ *
+ * This file provides the queue scheduler for zlib;
+ *
+ *****************************************************************************/
+
+#ifndef ZIP_QUEUE_SCHEDULER_H
+#define ZIP_QUEUE_SCHEDULER_H
+
+#include <pthread.h>
+
+struct zstrm_queue {
+    zip_streamp zstrm;
+    int using_flag;
+};
+
+struct zstrm_pool {
+    struct zstrm_queue hw_zstrm_queue[ZIP_QUEUE_SIZE];
+    int pool_size;
+    pthread_mutex_t mutex;
+};
+
+typedef struct zstrm_pool *zstrm_poolp;
+
+int zip_sched_put_queue(zstrm_poolp hw_queue_poolp, zip_streamp zstrm, unsigned int tid);
+zip_streamp zip_sched_get_queue(zstrm_poolp hw_queue_poolp, unsigned int tid);
+void zip_sched_release_queue(zstrm_poolp hw_queue_poolp);
+void zip_sched_release_spec_queue(zstrm_poolp hw_queue_poolp, zip_streamp zstrm);
+#endif
+
+
diff -Naru zlib-1.2.7/zip_zlib.h zlib-1.2.7_new/zip_zlib.h
--- zlib-1.2.7/zip_zlib.h	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zip_zlib.h	2020-06-12 14:47:58.910591800 +0800
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+/*****************************************************************************
+ * @file zip_zlib.h
+ *
+ * This file provides the interface for zlib;
+ *
+ *****************************************************************************/
+
+#ifndef ZIP_WD_H
+#define ZIP_WD_H
+#define ZIP_ACC
+#include "zlib.h"
+#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
+#include <fcntl.h>
+#include <io.h>
+#define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
+#else
+#define SET_BINARY_MODE(file)
+#endif
+
+#include "zip_common.h"
+
+#define ZLIB_MAX_WBITS    15
+#define ZLIB_MIN_WBITS    8
+#define GZIP_MAX_WBITS    31
+#define GZIP_MIN_WBITS    24
+#define DEFLATE_MAX_WBITS -8
+#define DEFLATE_MIN_WBITS -15
+
+int zip_deflate(z_streamp strm, int flush);
+int zip_inflate(z_streamp strm, int flush);
+int zip_inflateEnd(z_streamp strm);
+
+int sw_inflateEnd(z_streamp strm);
+
+int sw_deflateEnd(z_streamp strm);
+
+int zip_deflateEnd(z_streamp strm);
+
+int zip_deflateInit2_(z_streamp strm, int level, int metho, int windowBit, int memLevel, int strategy,
+                      const char *version, int stream_size);
+int zip_inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size);
+
+int sw_deflateInit2_(z_streamp strm, int level, int metho, int windowBit, int memLevel, int strategy,
+                     const char *version, int stream_size);
+int sw_inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size);
+
+int zip_inflateReset(z_streamp strm);
+int sw_inflateReset(z_streamp strm);
+int zip_inflateSync(z_streamp strm);
+
+#endif
+
diff -Naru zlib-1.2.7/zlib_acc_conf.c zlib-1.2.7_new/zlib_acc_conf.c
--- zlib-1.2.7/zlib_acc_conf.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zlib_acc_conf.c	2020-06-12 14:47:58.911592000 +0800
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+#include "zlib_acc_conf.h"
+
+int kae_drv_findsection(FILE *stream, const char *v_pszSection)
+{
+    char line[256]; // array length:256
+    char *pos = NULL;
+    size_t section_len = strlen(v_pszSection);
+
+    while (!feof(stream)) {
+        if (fgets(line, sizeof(line), stream) == NULL) {
+            return -1;
+        }
+
+        pos = line;
+        if (*(pos++) != '[') {
+            continue;
+        }
+
+        if (memcmp(pos, v_pszSection, section_len) == 0) {
+            pos += section_len;
+            if (*pos == ']') {
+                return 0;
+            }
+        }
+    }
+
+    return -1;
+}
+
+void kae_drv_get_value(char *pos, char *v_pszValue)
+{
+    while (*pos != '\0') {
+        if (*pos == ' ') {
+            pos++;
+            continue;
+        }
+
+        if (*pos == ';') {
+            *(v_pszValue++) = '\0';
+            return;
+        }
+
+        *(v_pszValue++) = *(pos++);
+    }
+}
+
+int kae_drv_find_item(FILE *stream, const char *v_pszItem, char *v_pszValue)
+{
+    char line[256]; // array length:256
+    char *pos = NULL;
+
+    while (!feof(stream)) {
+        if (fgets(line, sizeof(line), stream) == NULL) {
+            return -1;
+        }
+
+        if (strstr(line, v_pszItem) != NULL) {
+            pos = strstr(line, "=");
+            if (pos != NULL) {
+                pos++;
+                kae_drv_get_value(pos, v_pszValue);
+                return 0;
+            }
+        }
+
+        if ('[' == line[0]) {
+            break;
+        }
+    }
+
+    return -1;
+}
+
+int kae_drv_get_item(const char *config_file, const char *v_pszSection, 
+                     const char *v_pszItem, char *v_pszValue)
+{
+    FILE *stream;
+    int retvalue = -1;
+
+    stream = fopen(config_file, "r");
+    if (stream == NULL) {
+        return -1;
+    }
+
+    if (kae_drv_findsection(stream, v_pszSection) == 0) {
+        retvalue = kae_drv_find_item(stream, v_pszItem, v_pszValue);
+    }
+
+    fclose(stream);
+
+    return retvalue;
+}
diff -Naru zlib-1.2.7/zlib_acc_conf.h zlib-1.2.7_new/zlib_acc_conf.h
--- zlib-1.2.7/zlib_acc_conf.h	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zlib_acc_conf.h	2020-06-12 14:47:58.912092000 +0800
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+#ifndef HISI_ACC_OPENSSL_CONFIG_H
+#define HISI_ACC_OPENSSL_CONFIG_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int kae_drv_get_item(const char *config_file, const char *v_pszSection, 
+                     const char *v_pszItem, char *v_pszValue);
+
+#endif  // HISI_ACC_OPENSSL_CONFIG_H
diff -Naru zlib-1.2.7/zlib_acc_log.c zlib-1.2.7_new/zlib_acc_log.c
--- zlib-1.2.7/zlib_acc_log.c	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zlib_acc_log.c	2020-06-12 14:47:58.913592200 +0800
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include "zlib_acc_log.h"
+#include "zlib_acc_conf.h"
+
+#define KAE_CONFIG_FILE_NAME "/zlib_acc.cnf"
+#define MAX_LEVEL_LEN         10
+#define MAX_CONFIG_LEN        512
+
+static const char *g_kae_conf_env = "ZLIB_CONF_ENV";
+
+FILE *g_kae_debug_log_file = (FILE *)NULL;
+pthread_mutex_t g_debug_file_mutex = PTHREAD_MUTEX_INITIALIZER;
+int g_debug_file_ref_count = 0;
+int g_log_init_times = 0;
+int g_kae_log_level = 0;
+
+const char *g_log_level[] = {
+    "none",
+    "error",
+    "warning",
+    "info",
+    "debug",
+};
+
+static char *kae_getenv(const char *name)
+{
+    return getenv(name);
+}
+
+static void kae_set_conf_debuglevel()
+{
+    char *conf_path = kae_getenv(g_kae_conf_env);
+    unsigned int i = 0;
+    const char *filename = KAE_CONFIG_FILE_NAME;
+    char *file_path = (char *)NULL;
+    char *debuglev = (char *)NULL;
+    if (conf_path == NULL || strlen(conf_path) > MAX_CONFIG_LEN) {
+        goto err;
+    }
+    file_path = (char *)malloc(strlen(conf_path) + strlen(filename) + 1);
+    debuglev = (char *)malloc(MAX_LEVEL_LEN);
+    if (!file_path || !debuglev) {
+        goto err;
+    }
+    memset(debuglev, 0, MAX_LEVEL_LEN);
+    memset(file_path, 0, sizeof(conf_path) + sizeof(filename) + 1);
+    strcat(file_path, conf_path);
+    strcat(file_path, filename);
+    int ret = kae_drv_get_item(file_path, "LogSection", "debug_level", debuglev);
+    if (ret != 0) {
+        goto err;
+    }
+
+    for (i = 0; i < sizeof(g_log_level) / sizeof(g_log_level[0]); i++) {
+        if (strncmp(g_log_level[i], debuglev, strlen(debuglev) - 1) == 0) {
+            g_kae_log_level = i;
+            free(file_path);
+            free(debuglev);
+            return;
+        }
+    }
+
+err:
+    g_kae_log_level = KAE_NONE;
+    if (debuglev != NULL) {
+        free(debuglev);
+        debuglev = (char *)NULL;
+    }
+    if (file_path != NULL) {
+        free(file_path);
+        file_path = (char *)NULL;
+    }
+
+    return;
+}
+
+void kae_debug_init_log()
+{
+    pthread_mutex_lock(&g_debug_file_mutex);
+    kae_set_conf_debuglevel();
+    if (!g_debug_file_ref_count && g_kae_log_level != KAE_NONE) {
+        g_kae_debug_log_file = fopen(KAE_DEBUG_FILE_PATH, "a+");
+        if (g_kae_debug_log_file == NULL) {
+            g_kae_debug_log_file = stderr;
+            US_WARN("unable to open %s", KAE_DEBUG_FILE_PATH);
+        } else {
+            g_debug_file_ref_count++;
+        }
+    }
+    g_log_init_times++;
+    pthread_mutex_unlock(&g_debug_file_mutex);
+}
+
+void kae_debug_close_log()
+{
+    pthread_mutex_lock(&g_debug_file_mutex);
+    g_log_init_times--;
+    if (g_debug_file_ref_count && (g_log_init_times == 0)) {
+        if (g_kae_debug_log_file != NULL) {
+            fclose(g_kae_debug_log_file);
+            g_debug_file_ref_count--;
+            g_kae_debug_log_file = stderr;
+        }
+    }
+    pthread_mutex_unlock(&g_debug_file_mutex);
+}
+
+void ENGINE_LOG_LIMIT(int level, int times, int limit, const char *fmt, ...)
+{
+    struct tm *log_tm_p = (struct tm *)NULL;
+    static unsigned long ulpre = 0;
+    static int is_should_print = 5;
+
+    if (level > g_kae_log_level) {
+        return;
+    }
+    // cppcheck-suppress *
+    va_list args1 = { 0 };
+    va_start(args1, fmt);
+    time_t curr = time((time_t *)NULL);
+    if (difftime(curr, ulpre) > limit) {
+        is_should_print = times;
+    }
+    if (is_should_print <= 0) {
+        is_should_print = 0;
+    }
+    if (is_should_print-- > 0) {
+        log_tm_p = (struct tm *)localtime(&curr);
+        flock(g_kae_debug_log_file->_fileno, LOCK_EX);
+        pthread_mutex_lock(&g_debug_file_mutex);
+        fseek(g_kae_debug_log_file, 0, SEEK_END);
+        if (log_tm_p != NULL) {
+            fprintf(g_kae_debug_log_file, "[%4d-%02d-%02d %02d:%02d:%02d][%s][%s:%d:%s()] ",
+                    (1900 + log_tm_p->tm_year), (1 + log_tm_p->tm_mon), log_tm_p->tm_mday,   // base time 1900 year
+                    log_tm_p->tm_hour, log_tm_p->tm_min, log_tm_p->tm_sec,
+                    g_log_level[level], __FILE__, __LINE__, __func__);
+        } else {
+            fprintf(g_kae_debug_log_file, "[%s][%s:%d:%s()] ",
+                    g_log_level[level], __FILE__, __LINE__, __func__);
+        }
+        vfprintf(g_kae_debug_log_file, fmt, args1);
+        fprintf(g_kae_debug_log_file, "\n");
+        if (ftell(g_kae_debug_log_file) > KAE_LOG_MAX_SIZE) {
+            kae_save_log(g_kae_debug_log_file);
+            ftruncate(g_kae_debug_log_file->_fileno, 0);
+            fseek(g_kae_debug_log_file, 0, SEEK_SET);
+        }
+        pthread_mutex_unlock(&g_debug_file_mutex);
+        flock(g_kae_debug_log_file->_fileno, LOCK_UN);
+        ulpre = time((time_t *)NULL);
+    }
+
+    va_end(args1);
+}
+
+static int need_debug(void)
+{
+    if (g_kae_log_level >= KAE_DEBUG) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+void kae_save_log(FILE *src)
+{
+    int size = 0;
+    char buf[1024] = {0}; // buf length:1024
+
+    if (src == NULL) {
+        return;
+    }
+
+    FILE *dst = fopen(KAE_DEBUG_FILE_PATH_OLD, "w");
+    if (dst == NULL) {
+        return;
+    }
+
+    fseek(src, 0, SEEK_SET);
+    while (1) {
+        size = fread(buf, sizeof(char), 1024, src); // buf length:1024
+        fwrite(buf, sizeof(char), size, dst);
+        if (!size) {
+            break;
+        }
+    }
+
+    fclose(dst);
+}
+
diff -Naru zlib-1.2.7/zlib_acc_log.h zlib-1.2.7_new/zlib_acc_log.h
--- zlib-1.2.7/zlib_acc_log.h	1970-01-01 08:00:00.000000000 +0800
+++ zlib-1.2.7_new/zlib_acc_log.h	2020-06-12 14:47:58.915092400 +0800
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the zlib License. 
+ * You may obtain a copy of the License at
+ * 
+ *     https://www.zlib.net/zlib_license.html
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * zlib License for more details.
+ */
+
+#ifndef KAE_ACC_ENGINE_LOG_H
+#define KAE_ACC_ENGINE_LOG_H
+#include <sys/file.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <time.h>
+#include <pthread.h>
+
+
+#define LOG_LEVEL_CONFIG KAE_NONE
+#define KAE_DEBUG_FILE_PATH  "/var/log/zlib_acc.log"
+#define KAE_DEBUG_FILE_PATH_OLD "/var/log/zlib_acc.log.old"
+#define KAE_LOG_MAX_SIZE 209715200
+
+extern FILE *g_kae_debug_log_file;
+
+extern pthread_mutex_t g_debug_file_mutex;
+
+extern const char *g_log_level[];
+
+extern int g_kae_log_level;
+
+enum KAE_LOG_LEVEL {
+    KAE_NONE = 0,
+    KAE_ERROR,
+    KAE_WARNING,
+    KAE_INFO,
+    KAE_DEBUG,
+};
+
+void ENGINE_LOG_LIMIT(int level, int times, int limit, const char *fmt, ...);
+
+#define CRYPTO(LEVEL, fmt, args...)                                                                     \
+    do {                                                                                                \
+        if (LEVEL > g_kae_log_level) {                                                                  \
+            break;                                                                                      \
+        }                                                                                               \
+        struct tm *log_tm_p = NULL;                                                                     \
+        time_t timep = time((time_t *)NULL);                                                            \
+        log_tm_p = localtime(&timep);                                                                   \
+        flock(g_kae_debug_log_file->_fileno, LOCK_EX);                                                  \
+        pthread_mutex_lock(&g_debug_file_mutex);                                                        \
+        fseek(g_kae_debug_log_file, 0, SEEK_END);                                                       \
+        if (log_tm_p != NULL) {                                                                         \
+            fprintf(g_kae_debug_log_file, "[%4d-%02d-%02d %02d:%02d:%02d][%s][%s:%d:%s()] " fmt "\n",   \
+                (1900 + log_tm_p->tm_year), (1 + log_tm_p->tm_mon), log_tm_p->tm_mday,                  \
+                log_tm_p->tm_hour, log_tm_p->tm_min, log_tm_p->tm_sec,                                  \
+                g_log_level[LEVEL], __FILE__, __LINE__, __func__, ##args);                              \
+        } else {                                                                                        \
+            fprintf(g_kae_debug_log_file, "[%s][%s:%d:%s()] " fmt "\n",                                 \
+                g_log_level[LEVEL], __FILE__, __LINE__, __func__, ##args);                              \
+        }                                                                                               \
+        if (ftell(g_kae_debug_log_file) > KAE_LOG_MAX_SIZE) {                                           \
+            kae_save_log(g_kae_debug_log_file);                                                         \
+            ftruncate(g_kae_debug_log_file->_fileno, 0);                                                \
+            fseek(g_kae_debug_log_file, 0, SEEK_SET);                                                   \
+        }                                                                                               \
+            pthread_mutex_unlock(&g_debug_file_mutex);                                                  \
+            flock(g_kae_debug_log_file->_fileno, LOCK_UN);                                              \
+    } while (0)
+
+#define US_ERR(fmt, args...)          CRYPTO(KAE_ERROR, fmt, ##args)
+#define US_WARN(fmt, args...)         CRYPTO(KAE_WARNING, fmt, ##args)
+#define US_INFO(fmt, args...)         CRYPTO(KAE_INFO, fmt, ##args)
+#define US_DEBUG(fmt, args...)        CRYPTO(KAE_DEBUG, fmt, ##args)
+#define US_WARN_LIMIT(fmt, args...)   ENGINE_LOG_LIMIT(KAE_WARNING, 3, 30, fmt, ##args)
+#define US_ERR_LIMIT(fmt, args...)    ENGINE_LOG_LIMIT(KAE_ERROR, 3, 30, fmt, ##args)
+#define US_INFO_LIMIT(fmt, args...)   ENGINE_LOG_LIMIT(KAE_INFO, 3, 30, fmt, ##args)
+#define US_DEBUG_LIMIT(fmt, args...)  ENGINE_LOG_LIMIT(KAE_DEBUG, 3, 30, fmt, ##args)
+
+void kae_debug_init_log();
+void kae_debug_close_log();
+void kae_save_log(FILE *src);
+
+#endif
